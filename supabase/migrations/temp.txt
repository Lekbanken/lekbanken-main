-- =========================================
-- LEKBANKEN INITIAL SCHEMA
-- Version 1.1
-- Date: 2025-11-29
-- =========================================
-- This migration creates the complete Lekbanken database schema
-- including all tables, indexes, enums, RLS policies and auth triggers.
-- =========================================

-- =========================================
-- 1. ENUM TYPES
-- =========================================

CREATE TYPE language_code_enum AS ENUM ('NO', 'SE', 'EN');

CREATE TYPE subscription_status_enum AS ENUM (
  'active',
  'paused',
  'canceled',
  'trial'
);

CREATE TYPE seat_assignment_status_enum AS ENUM (
  'active',
  'released',
  'pending',
  'revoked'
);

CREATE TYPE invoice_status_enum AS ENUM (
  'draft',
  'issued',
  'sent',
  'paid',
  'overdue',
  'canceled'
);

CREATE TYPE payment_status_enum AS ENUM (
  'pending',
  'confirmed',
  'failed',
  'refunded'
);

CREATE TYPE game_status_enum AS ENUM (
  'draft',
  'published'
);

CREATE TYPE plan_visibility_enum AS ENUM (
  'private',
  'tenant',
  'public'
);

CREATE TYPE purpose_type_enum AS ENUM (
  'main',
  'sub'
);

CREATE TYPE media_type_enum AS ENUM (
  'template',
  'upload',
  'ai'
);

-- =========================================
-- 2. CORE TABLES: TENANTS & USERS
-- =========================================

CREATE TABLE tenants (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_key      text UNIQUE,
  name            text NOT NULL,
  type            text NOT NULL,
  status          text NOT NULL DEFAULT 'active',
  main_language   language_code_enum NOT NULL DEFAULT 'NO',
  created_at      timestamptz NOT NULL DEFAULT now(),
  updated_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX tenants_tenant_key_idx ON tenants (tenant_key);
CREATE INDEX tenants_status_idx ON tenants (status);

-- Users table (synced with Supabase auth.users via trigger)
CREATE TABLE users (
  id                uuid PRIMARY KEY,
  email             text NOT NULL UNIQUE,
  full_name         text,
  role              text NOT NULL DEFAULT 'member',
  language          language_code_enum NOT NULL DEFAULT 'NO',
  created_at        timestamptz NOT NULL DEFAULT now(),
  updated_at        timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX users_email_idx ON users (email);
CREATE INDEX users_role_idx ON users (role);

-- =========================================
-- 3. USER ↔ TENANT MEMBERSHIPS (M:M)
-- =========================================

CREATE TABLE user_tenant_memberships (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id         uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id       uuid NOT NULL REFERENCES tenants (id) ON DELETE CASCADE,
  role            text NOT NULL DEFAULT 'member',
  is_primary      boolean NOT NULL DEFAULT false,
  created_at      timestamptz NOT NULL DEFAULT now(),
  updated_at      timestamptz NOT NULL DEFAULT now(),
  UNIQUE (user_id, tenant_id)
);

CREATE INDEX user_tenant_memberships_user_idx ON user_tenant_memberships (user_id);
CREATE INDEX user_tenant_memberships_tenant_idx ON user_tenant_memberships (tenant_id);
CREATE INDEX user_tenant_memberships_role_idx ON user_tenant_memberships (role);

-- =========================================
-- 4. PRODUCT & PURPOSE LAYER
-- =========================================

CREATE TABLE products (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  product_key     text UNIQUE,
  name            text NOT NULL,
  category        text NOT NULL,
  description     text,
  created_at      timestamptz NOT NULL DEFAULT now(),
  updated_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX products_product_key_idx ON products (product_key);
CREATE INDEX products_category_idx ON products (category);

CREATE TABLE purposes (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  purpose_key     text UNIQUE,
  name            text NOT NULL,
  type            purpose_type_enum NOT NULL,
  parent_id       uuid REFERENCES purposes (id) ON DELETE CASCADE,
  created_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX purposes_purpose_key_idx ON purposes (purpose_key);
CREATE INDEX purposes_type_idx ON purposes (type);
CREATE INDEX purposes_parent_idx ON purposes (parent_id);

-- PRODUCTS ↔ PURPOSES (M:M)
CREATE TABLE product_purposes (
  product_id  uuid NOT NULL REFERENCES products (id) ON DELETE CASCADE,
  purpose_id  uuid NOT NULL REFERENCES purposes (id) ON DELETE CASCADE,
  PRIMARY KEY (product_id, purpose_id)
);

CREATE INDEX product_purposes_product_idx ON product_purposes (product_id);
CREATE INDEX product_purposes_purpose_idx ON product_purposes (purpose_id);

-- =========================================
-- 5. GAMES & MEDIA (Games Domain)
-- =========================================

CREATE TABLE games (
  id                uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  game_key          text UNIQUE,
  name              text NOT NULL,
  description       text,
  instructions      text,
  product_id        uuid REFERENCES products (id) ON DELETE SET NULL,
  main_purpose_id   uuid REFERENCES purposes (id) ON DELETE SET NULL,
  owner_tenant_id   uuid REFERENCES tenants (id) ON DELETE SET NULL,
  status            game_status_enum NOT NULL DEFAULT 'draft',
  energy_level      text,
  time_estimate_min integer,
  min_players       integer,
  max_players       integer,
  age_min           integer,
  age_max           integer,
  location_type     text,
  materials         text,
  created_at        timestamptz NOT NULL DEFAULT now(),
  updated_at        timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX games_game_key_idx ON games (game_key);
CREATE INDEX games_product_idx ON games (product_id);
CREATE INDEX games_main_purpose_idx ON games (main_purpose_id);
CREATE INDEX games_owner_tenant_idx ON games (owner_tenant_id);
CREATE INDEX games_status_idx ON games (status);

-- GAMES ↔ SECONDARY PURPOSES (M:M)
CREATE TABLE game_secondary_purposes (
  game_id    uuid NOT NULL REFERENCES games (id) ON DELETE CASCADE,
  purpose_id uuid NOT NULL REFERENCES purposes (id) ON DELETE CASCADE,
  PRIMARY KEY (game_id, purpose_id)
);

CREATE INDEX game_secondary_purposes_game_idx ON game_secondary_purposes (game_id);
CREATE INDEX game_secondary_purposes_purpose_idx ON game_secondary_purposes (purpose_id);

-- Media table
CREATE TABLE media (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  media_key       text UNIQUE,
  name            text NOT NULL,
  type            media_type_enum NOT NULL,
  product_id      uuid REFERENCES products (id) ON DELETE SET NULL,
  purpose_id      uuid REFERENCES purposes (id) ON DELETE SET NULL,
  game_id         uuid REFERENCES games (id) ON DELETE CASCADE,
  url             text NOT NULL,
  alt_text        text,
  created_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX media_media_key_idx ON media (media_key);
CREATE INDEX media_product_idx ON media (product_id);
CREATE INDEX media_purpose_idx ON media (purpose_id);
CREATE INDEX media_game_idx ON media (game_id);
CREATE INDEX media_type_idx ON media (type);

-- =========================================
-- 6. PLANS (Planner Domain)
-- =========================================

CREATE TABLE plans (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_key            text UNIQUE,
  name                text NOT NULL,
  description         text,
  owner_user_id       uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  owner_tenant_id     uuid REFERENCES tenants (id) ON DELETE CASCADE,
  visibility          plan_visibility_enum NOT NULL DEFAULT 'private',
  total_time_minutes  integer,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX plans_plan_key_idx ON plans (plan_key);
CREATE INDEX plans_owner_user_idx ON plans (owner_user_id);
CREATE INDEX plans_owner_tenant_idx ON plans (owner_tenant_id);
CREATE INDEX plans_visibility_idx ON plans (visibility);

-- PLANS ↔ GAMES (M:M + order)
CREATE TABLE plan_games (
  plan_id     uuid NOT NULL REFERENCES plans (id) ON DELETE CASCADE,
  game_id     uuid NOT NULL REFERENCES games (id) ON DELETE CASCADE,
  position    integer NOT NULL,
  PRIMARY KEY (plan_id, game_id),
  UNIQUE (plan_id, position)
);

CREATE INDEX plan_games_plan_idx ON plan_games (plan_id);
CREATE INDEX plan_games_game_idx ON plan_games (game_id);
CREATE INDEX plan_games_position_idx ON plan_games (plan_id, position);

-- Plan blocks (for future: pauses, custom notes)
CREATE TABLE plan_blocks (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_id         uuid NOT NULL REFERENCES plans (id) ON DELETE CASCADE,
  position        integer NOT NULL,
  block_type      text NOT NULL,
  game_id         uuid REFERENCES games (id) ON DELETE SET NULL,
  duration_minutes integer,
  notes           text,
  created_at      timestamptz NOT NULL DEFAULT now(),
  UNIQUE (plan_id, position)
);

CREATE INDEX plan_blocks_plan_idx ON plan_blocks (plan_id);
CREATE INDEX plan_blocks_position_idx ON plan_blocks (plan_id, position);

-- =========================================
-- 7. BILLING & SUBSCRIPTIONS
-- =========================================

CREATE TABLE billing_products (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  billing_product_key text UNIQUE,
  name                text NOT NULL,
  type                text NOT NULL,
  price_per_seat      numeric(10,2) NOT NULL,
  currency            text NOT NULL DEFAULT 'NOK',
  seats_included      integer NOT NULL DEFAULT 1,
  is_active           boolean NOT NULL DEFAULT true,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX billing_products_type_idx ON billing_products (type);
CREATE INDEX billing_products_active_idx ON billing_products (is_active);

-- Tenant subscriptions
CREATE TABLE tenant_subscriptions (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_key    text UNIQUE,
  tenant_id           uuid NOT NULL REFERENCES tenants (id) ON DELETE CASCADE,
  billing_product_id  uuid NOT NULL REFERENCES billing_products (id),
  status              subscription_status_enum NOT NULL DEFAULT 'trial',
  seats_purchased     integer NOT NULL DEFAULT 1,
  start_date          date NOT NULL,
  renewal_date        date,
  cancelled_at        timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX tenant_subscriptions_tenant_idx ON tenant_subscriptions (tenant_id);
CREATE INDEX tenant_subscriptions_billing_product_idx ON tenant_subscriptions (billing_product_id);
CREATE INDEX tenant_subscriptions_status_idx ON tenant_subscriptions (status);

-- Private subscriptions
CREATE TABLE private_subscriptions (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_key    text UNIQUE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  billing_product_id  uuid NOT NULL REFERENCES billing_products (id),
  status              subscription_status_enum NOT NULL DEFAULT 'trial',
  start_date          date NOT NULL,
  renewal_date        date,
  cancelled_at        timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX private_subscriptions_user_idx ON private_subscriptions (user_id);
CREATE INDEX private_subscriptions_billing_product_idx ON private_subscriptions (billing_product_id);
CREATE INDEX private_subscriptions_status_idx ON private_subscriptions (status);

-- Tenant seat assignments
CREATE TABLE tenant_seat_assignments (
  id                    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  seat_assignment_key   text UNIQUE,
  name                  text,
  tenant_id             uuid NOT NULL REFERENCES tenants (id) ON DELETE CASCADE,
  user_id               uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  subscription_id       uuid NOT NULL REFERENCES tenant_subscriptions (id) ON DELETE CASCADE,
  billing_product_id    uuid NOT NULL REFERENCES billing_products (id),
  status                seat_assignment_status_enum NOT NULL DEFAULT 'pending',
  assigned_at           timestamptz NOT NULL DEFAULT now(),
  assigned_by_user_id   uuid REFERENCES users (id),
  released_at           timestamptz,
  created_at            timestamptz NOT NULL DEFAULT now(),
  updated_at            timestamptz NOT NULL DEFAULT now(),
  UNIQUE (tenant_id, user_id, subscription_id)
);

CREATE INDEX tenant_seat_assignments_tenant_idx ON tenant_seat_assignments (tenant_id);
CREATE INDEX tenant_seat_assignments_user_idx ON tenant_seat_assignments (user_id);
CREATE INDEX tenant_seat_assignments_subscription_idx ON tenant_seat_assignments (subscription_id);
CREATE INDEX tenant_seat_assignments_status_idx ON tenant_seat_assignments (status);

-- Invoices
CREATE TABLE invoices (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_key         text UNIQUE,
  name                text NOT NULL,
  tenant_id           uuid NOT NULL REFERENCES tenants (id) ON DELETE CASCADE,
  subscription_id     uuid REFERENCES tenant_subscriptions (id),
  billing_product_id  uuid REFERENCES billing_products (id),
  amount              numeric(10,2) NOT NULL,
  currency            text NOT NULL DEFAULT 'NOK',
  status              invoice_status_enum NOT NULL DEFAULT 'draft',
  due_date            date NOT NULL,
  issued_at           timestamptz,
  paid_at             timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX invoices_tenant_idx ON invoices (tenant_id);
CREATE INDEX invoices_subscription_idx ON invoices (subscription_id);
CREATE INDEX invoices_status_idx ON invoices (status);
CREATE INDEX invoices_due_date_idx ON invoices (due_date);

-- Payments
CREATE TABLE payments (
  id                    uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  payment_key           text UNIQUE,
  name                  text NOT NULL,
  invoice_id            uuid NOT NULL REFERENCES invoices (id) ON DELETE CASCADE,
  amount                numeric(10,2) NOT NULL,
  currency              text NOT NULL DEFAULT 'NOK',
  status                payment_status_enum NOT NULL DEFAULT 'pending',
  provider              text,
  transaction_reference text,
  paid_at               timestamptz,
  created_at            timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX payments_invoice_idx ON payments (invoice_id);
CREATE INDEX payments_status_idx ON payments (status);
CREATE INDEX payments_provider_idx ON payments (provider);
CREATE INDEX payments_transaction_reference_idx ON payments (transaction_reference);

-- =========================================
-- 8. SEARCH & BROWSE LOGGING
-- =========================================

CREATE TABLE browse_search_logs (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id         uuid REFERENCES users (id) ON DELETE SET NULL,
  tenant_id       uuid REFERENCES tenants (id) ON DELETE SET NULL,
  search_term     text,
  filters_applied jsonb,
  results_count   integer,
  result_ids      uuid[],
  created_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX browse_search_logs_user_idx ON browse_search_logs (user_id);
CREATE INDEX browse_search_logs_tenant_idx ON browse_search_logs (tenant_id);
CREATE INDEX browse_search_logs_created_idx ON browse_search_logs (created_at);

-- =========================================
-- 9. ENABLE ROW LEVEL SECURITY
-- =========================================

ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_tenant_memberships ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE purposes ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_purposes ENABLE ROW LEVEL SECURITY;
ALTER TABLE games ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_secondary_purposes ENABLE ROW LEVEL SECURITY;
ALTER TABLE media ENABLE ROW LEVEL SECURITY;
ALTER TABLE plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE plan_games ENABLE ROW LEVEL SECURITY;
ALTER TABLE plan_blocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE billing_products ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE private_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_seat_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE browse_search_logs ENABLE ROW LEVEL SECURITY;

-- =========================================
-- 10. RLS HELPER FUNCTIONS
-- =========================================

-- Check if user is member of a tenant
CREATE OR REPLACE FUNCTION is_tenant_member(tenant_uuid uuid)
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM user_tenant_memberships
    WHERE user_id = auth.uid()
      AND tenant_id = tenant_uuid
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get all tenant IDs user is member of
CREATE OR REPLACE FUNCTION get_user_tenant_ids()
RETURNS uuid[] AS $$
  SELECT array_agg(tenant_id)
  FROM user_tenant_memberships
  WHERE user_id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER;

-- Check if user has specific role in tenant
CREATE OR REPLACE FUNCTION has_tenant_role(tenant_uuid uuid, required_role text)
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM user_tenant_memberships
    WHERE user_id = auth.uid()
      AND tenant_id = tenant_uuid
      AND role = required_role
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =========================================
-- 11. RLS POLICIES
-- =========================================

-- TENANTS: Users can select tenants they are members of
CREATE POLICY "tenant_members_can_select"
ON tenants FOR SELECT
USING (
  id = ANY(get_user_tenant_ids())
);

-- USERS: Users can select users in their tenants
CREATE POLICY "tenant_members_can_select_users"
ON users FOR SELECT
USING (
  id = auth.uid()
  OR id IN (
    SELECT user_id FROM user_tenant_memberships
    WHERE tenant_id = ANY(get_user_tenant_ids())
  )
);

-- USERS: Users can update their own profile
CREATE POLICY "users_can_update_own_profile"
ON users FOR UPDATE
USING (id = auth.uid());

-- USER_TENANT_MEMBERSHIPS: Users can see their own memberships
CREATE POLICY "users_can_select_own_memberships"
ON user_tenant_memberships FOR SELECT
USING (user_id = auth.uid());

-- USER_TENANT_MEMBERSHIPS: Tenant admins can see all memberships in their tenant
CREATE POLICY "tenant_admins_can_select_memberships"
ON user_tenant_memberships FOR SELECT
USING (
  has_tenant_role(tenant_id, 'admin') OR has_tenant_role(tenant_id, 'owner')
);

-- PRODUCTS & PURPOSES: All authenticated users can read
CREATE POLICY "authenticated_can_select_products"
ON products FOR SELECT
USING (auth.role() = 'authenticated');

CREATE POLICY "authenticated_can_select_purposes"
ON purposes FOR SELECT
USING (auth.role() = 'authenticated');

CREATE POLICY "authenticated_can_select_product_purposes"
ON product_purposes FOR SELECT
USING (auth.role() = 'authenticated');

-- GAMES: Users can select games owned by their tenants or published global games
CREATE POLICY "users_can_select_games"
ON games FOR SELECT
USING (
  owner_tenant_id = ANY(get_user_tenant_ids())
  OR (owner_tenant_id IS NULL AND status = 'published')
  OR (owner_tenant_id IS NULL)
);

-- GAMES: Tenant members can insert games for their tenant
CREATE POLICY "tenant_members_can_insert_games"
ON games FOR INSERT
WITH CHECK (
  owner_tenant_id = ANY(get_user_tenant_ids())
);

-- GAMES: Tenant members can update games owned by their tenant
CREATE POLICY "tenant_members_can_update_games"
ON games FOR UPDATE
USING (
  owner_tenant_id = ANY(get_user_tenant_ids())
);

-- GAMES: Tenant admins can delete games owned by their tenant
CREATE POLICY "tenant_admins_can_delete_games"
ON games FOR DELETE
USING (
  owner_tenant_id = ANY(get_user_tenant_ids())
  AND (has_tenant_role(owner_tenant_id, 'admin') OR has_tenant_role(owner_tenant_id, 'owner'))
);

-- GAME_SECONDARY_PURPOSES
CREATE POLICY "users_can_select_game_secondary_purposes"
ON game_secondary_purposes FOR SELECT
USING (
  game_id IN (
    SELECT id FROM games
    WHERE owner_tenant_id = ANY(get_user_tenant_ids())
       OR (owner_tenant_id IS NULL)
  )
);

-- MEDIA: Users can select media linked to games they have access to
CREATE POLICY "users_can_select_media"
ON media FOR SELECT
USING (
  game_id IN (
    SELECT id FROM games
    WHERE owner_tenant_id = ANY(get_user_tenant_ids())
       OR owner_tenant_id IS NULL
  )
  OR game_id IS NULL
);

-- MEDIA: Tenant members can insert media
CREATE POLICY "tenant_members_can_insert_media"
ON media FOR INSERT
WITH CHECK (
  game_id IN (
    SELECT id FROM games
    WHERE owner_tenant_id = ANY(get_user_tenant_ids())
  )
  OR game_id IS NULL
);

-- PLANS: Users can select their own plans, tenant plans, or public plans
CREATE POLICY "users_can_select_plans"
ON plans FOR SELECT
USING (
  owner_user_id = auth.uid()
  OR (visibility = 'tenant' AND owner_tenant_id = ANY(get_user_tenant_ids()))
  OR visibility = 'public'
);

-- PLANS: Users can insert their own plans
CREATE POLICY "users_can_insert_plans"
ON plans FOR INSERT
WITH CHECK (
  owner_user_id = auth.uid()
  AND (
    owner_tenant_id IS NULL
    OR owner_tenant_id = ANY(get_user_tenant_ids())
  )
);

-- PLANS: Users can update their own plans
CREATE POLICY "users_can_update_own_plans"
ON plans FOR UPDATE
USING (owner_user_id = auth.uid());

-- PLANS: Users can delete their own plans
CREATE POLICY "users_can_delete_own_plans"
ON plans FOR DELETE
USING (owner_user_id = auth.uid());

-- PLAN_GAMES
CREATE POLICY "users_can_select_plan_games"
ON plan_games FOR SELECT
USING (
  plan_id IN (
    SELECT id FROM plans
    WHERE owner_user_id = auth.uid()
       OR (visibility = 'tenant' AND owner_tenant_id = ANY(get_user_tenant_ids()))
       OR visibility = 'public'
  )
);

CREATE POLICY "users_can_manage_own_plan_games"
ON plan_games FOR INSERT
WITH CHECK (
  plan_id IN (
    SELECT id FROM plans
    WHERE owner_user_id = auth.uid()
  )
);

-- PLAN_BLOCKS
CREATE POLICY "users_can_select_plan_blocks"
ON plan_blocks FOR SELECT
USING (
  plan_id IN (
    SELECT id FROM plans
    WHERE owner_user_id = auth.uid()
       OR (visibility = 'tenant' AND owner_tenant_id = ANY(get_user_tenant_ids()))
       OR visibility = 'public'
  )
);

-- BILLING_PRODUCTS: All authenticated users can read active products
CREATE POLICY "authenticated_can_select_active_billing_products"
ON billing_products FOR SELECT
USING (auth.role() = 'authenticated' AND is_active = true);

-- TENANT_SUBSCRIPTIONS: Tenant members can select
CREATE POLICY "tenant_members_can_select_subscriptions"
ON tenant_subscriptions FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- PRIVATE_SUBSCRIPTIONS: Users can select their own
CREATE POLICY "users_can_select_own_private_subscriptions"
ON private_subscriptions FOR SELECT
USING (user_id = auth.uid());

-- TENANT_SEAT_ASSIGNMENTS
CREATE POLICY "tenant_members_can_select_seat_assignments"
ON tenant_seat_assignments FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
  OR user_id = auth.uid()
);

-- INVOICES: Tenant members can select
CREATE POLICY "tenant_members_can_select_invoices"
ON invoices FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- PAYMENTS: Tenant members can select
CREATE POLICY "tenant_members_can_select_payments"
ON payments FOR SELECT
USING (
  invoice_id IN (
    SELECT id FROM invoices
    WHERE tenant_id = ANY(get_user_tenant_ids())
  )
);

-- BROWSE_SEARCH_LOGS: Users can see their own logs
CREATE POLICY "users_can_select_own_search_logs"
ON browse_search_logs FOR SELECT
USING (
  user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- =========================================
-- 12. AUTH TRIGGER FOR USER SYNC
-- =========================================

-- Function to sync auth.users to public.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.users (id, email, full_name, role, language)
  VALUES (
    new.id,
    new.email,
    COALESCE(new.raw_user_meta_data->>'full_name', ''),
    'member',
    COALESCE((new.raw_user_meta_data->>'language')::language_code_enum, 'NO')
  )
  ON CONFLICT (id) DO UPDATE SET
    email = new.email,
    full_name = COALESCE(new.raw_user_meta_data->>'full_name', '');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- Trigger the function every time a user is created
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =========================================
-- 13. SEED DATA (Optional - for testing)
-- =========================================

-- Insert default products
INSERT INTO products (product_key, name, category, description) VALUES
  ('trainer', 'Tränare', 'Sports', 'För träning och sport'),
  ('pedagog', 'Pedagog', 'Education', 'För pedagoger och lärare'),
  ('parent', 'Förälder', 'Family', 'För föräldrar och hemmet')
ON CONFLICT (product_key) DO NOTHING;

-- Insert default purposes (main)
INSERT INTO purposes (purpose_key, name, type) VALUES
  ('coordination', 'Samordning', 'main'),
  ('strength', 'Styrka', 'main'),
  ('creativity', 'Kreativitet', 'main'),
  ('social', 'Social', 'main'),
  ('focus', 'Fokus', 'main')
ON CONFLICT (purpose_key) DO NOTHING;

-- Insert default purposes (sub)
INSERT INTO purposes (purpose_key, name, type, parent_id) 
SELECT
  'hand-eye-coord',
  'Hand-öga-koordination',
  'sub',
  (SELECT id FROM purposes WHERE purpose_key = 'coordination')
ON CONFLICT (purpose_key) DO NOTHING;

-- Insert default billing products
INSERT INTO billing_products (billing_product_key, name, type, price_per_seat, currency) VALUES
  ('trainer-monthly', 'Tränare - Månad', 'subscription', 199, 'NOK'),
  ('pedagog-monthly', 'Pedagog - Månad', 'subscription', 299, 'NOK'),
  ('private-yearly', 'Privat - År', 'subscription', 1990, 'NOK')
ON CONFLICT (billing_product_key) DO NOTHING;

-- =========================================
-- 14. END OF MIGRATION
-- =========================================

COMMENT ON TABLE tenants IS 'Organizations/teams in Lekbanken';
COMMENT ON TABLE users IS 'Users synced from Supabase Auth';
COMMENT ON TABLE user_tenant_memberships IS 'Many-to-many relationship between users and tenants with roles';
COMMENT ON TABLE games IS 'Core game/activity database';
COMMENT ON TABLE plans IS 'User-created plans combining multiple games';
COMMENT ON TABLE browse_search_logs IS 'Logs for search analytics and recommendations';

-- Fix security warnings for RLS functions
-- Add SECURITY DEFINER and locked search_path to prevent privilege escalation

-- Drop existing functions
DROP FUNCTION IF EXISTS public.is_tenant_member(uuid) CASCADE;
DROP FUNCTION IF EXISTS public.get_user_tenant_ids() CASCADE;
DROP FUNCTION IF EXISTS public.has_tenant_role(uuid, text) CASCADE;

-- Recreate is_tenant_member with SECURITY DEFINER
CREATE FUNCTION public.is_tenant_member(tenant_id uuid)
  RETURNS boolean
  LANGUAGE plpgsql
  SECURITY DEFINER
  SET search_path = public
  AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_tenant_memberships
    WHERE user_id = auth.uid()
    AND tenant_id = $1
    AND deleted_at IS NULL
  );
END;
$$;

-- Recreate get_user_tenant_ids with SECURITY DEFINER
CREATE FUNCTION public.get_user_tenant_ids()
  RETURNS uuid[]
  LANGUAGE plpgsql
  SECURITY DEFINER
  SET search_path = public
  AS $$
BEGIN
  RETURN ARRAY(
    SELECT tenant_id FROM user_tenant_memberships
    WHERE user_id = auth.uid()
    AND deleted_at IS NULL
  );
END;
$$;

-- Recreate has_tenant_role with SECURITY DEFINER
CREATE FUNCTION public.has_tenant_role(tenant_id uuid, required_role text)
  RETURNS boolean
  LANGUAGE plpgsql
  SECURITY DEFINER
  SET search_path = public
  AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_tenant_memberships
    WHERE user_id = auth.uid()
    AND tenant_id = $1
    AND role = required_role::user_role_enum
    AND deleted_at IS NULL
  );
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION public.is_tenant_member TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_tenant_ids TO authenticated;
GRANT EXECUTE ON FUNCTION public.has_tenant_role TO authenticated;

-- Prevent public access
REVOKE EXECUTE ON FUNCTION public.is_tenant_member FROM public;
REVOKE EXECUTE ON FUNCTION public.get_user_tenant_ids FROM public;
REVOKE EXECUTE ON FUNCTION public.has_tenant_role FROM public;

-- =========================================
-- PLAY DOMAIN SCHEMA
-- Version 1.0
-- Date: 2025-11-29
-- =========================================
-- This migration adds game sessions, scores, and leaderboards for the Play Domain

-- =========================================
-- 1. ENUM TYPES
-- =========================================

CREATE TYPE session_status_enum AS ENUM (
  'active',
  'paused',
  'completed',
  'abandoned'
);

-- =========================================
-- 2. GAME SESSIONS TABLE
-- =========================================

CREATE TABLE game_sessions (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  session_key         text UNIQUE,
  game_id             uuid NOT NULL REFERENCES games (id) ON DELETE CASCADE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  status              session_status_enum NOT NULL DEFAULT 'active',
  score               integer DEFAULT 0,
  duration_seconds    integer DEFAULT 0,
  started_at          timestamptz NOT NULL DEFAULT now(),
  ended_at            timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX game_sessions_session_key_idx ON game_sessions (session_key);
CREATE INDEX game_sessions_game_idx ON game_sessions (game_id);
CREATE INDEX game_sessions_user_idx ON game_sessions (user_id);
CREATE INDEX game_sessions_tenant_idx ON game_sessions (tenant_id);
CREATE INDEX game_sessions_status_idx ON game_sessions (status);
CREATE INDEX game_sessions_created_at_idx ON game_sessions (created_at);

-- =========================================
-- 3. GAME SCORES TABLE
-- =========================================

CREATE TABLE game_scores (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  score_key           text UNIQUE,
  session_id          uuid NOT NULL REFERENCES game_sessions (id) ON DELETE CASCADE,
  game_id             uuid NOT NULL REFERENCES games (id) ON DELETE CASCADE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  score               integer NOT NULL DEFAULT 0,
  score_type          text DEFAULT 'points',
  metadata            jsonb,
  recorded_at         timestamptz NOT NULL DEFAULT now(),
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX game_scores_score_key_idx ON game_scores (score_key);
CREATE INDEX game_scores_session_idx ON game_scores (session_id);
CREATE INDEX game_scores_game_idx ON game_scores (game_id);
CREATE INDEX game_scores_user_idx ON game_scores (user_id);
CREATE INDEX game_scores_tenant_idx ON game_scores (tenant_id);
CREATE INDEX game_scores_created_at_idx ON game_scores (created_at);

-- =========================================
-- 4. LEADERBOARDS TABLE (Aggregated scores)
-- =========================================

CREATE TABLE leaderboards (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  leaderboard_key     text UNIQUE,
  game_id             uuid REFERENCES games (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  leaderboard_type    text NOT NULL DEFAULT 'global', -- global, tenant, personal
  user_id             uuid REFERENCES users (id) ON DELETE CASCADE,
  total_score         integer NOT NULL DEFAULT 0,
  total_sessions      integer NOT NULL DEFAULT 0,
  avg_score           numeric(10,2),
  best_score          integer,
  worst_score         integer,
  last_played_at      timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX leaderboards_leaderboard_key_idx ON leaderboards (leaderboard_key);
CREATE INDEX leaderboards_game_idx ON leaderboards (game_id);
CREATE INDEX leaderboards_tenant_idx ON leaderboards (tenant_id);
CREATE INDEX leaderboards_user_idx ON leaderboards (user_id);
CREATE INDEX leaderboards_leaderboard_type_idx ON leaderboards (leaderboard_type);
CREATE INDEX leaderboards_total_score_idx ON leaderboards (total_score DESC);
CREATE INDEX leaderboards_updated_at_idx ON leaderboards (updated_at);

-- =========================================
-- 5. ACHIEVEMENTS TABLE
-- =========================================

CREATE TABLE achievements (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  achievement_key     text UNIQUE,
  name                text NOT NULL,
  description         text,
  icon_url            text,
  badge_color         text,
  condition_type      text NOT NULL, -- score_milestone, session_count, streak, etc.
  condition_value     integer,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX achievements_achievement_key_idx ON achievements (achievement_key);
CREATE INDEX achievements_condition_type_idx ON achievements (condition_type);

-- =========================================
-- 6. USER ACHIEVEMENTS TABLE
-- =========================================

CREATE TABLE user_achievements (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  achievement_id      uuid NOT NULL REFERENCES achievements (id) ON DELETE CASCADE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  unlocked_at         timestamptz NOT NULL DEFAULT now(),
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX user_achievements_achievement_idx ON user_achievements (achievement_id);
CREATE INDEX user_achievements_user_idx ON user_achievements (user_id);
CREATE INDEX user_achievements_tenant_idx ON user_achievements (tenant_id);
CREATE INDEX user_achievements_unlocked_at_idx ON user_achievements (unlocked_at);

-- =========================================
-- 7. ENABLE ROW LEVEL SECURITY
-- =========================================

ALTER TABLE game_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE leaderboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_achievements ENABLE ROW LEVEL SECURITY;

-- =========================================
-- 8. RLS POLICIES
-- =========================================

-- GAME_SESSIONS: Users can select their own sessions and tenant members can see tenant sessions
CREATE POLICY "users_can_select_own_game_sessions"
ON game_sessions FOR SELECT
USING (
  user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- GAME_SESSIONS: Users can insert their own sessions
CREATE POLICY "users_can_insert_own_game_sessions"
ON game_sessions FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  AND (
    tenant_id IS NULL
    OR tenant_id = ANY(get_user_tenant_ids())
  )
);

-- GAME_SESSIONS: Users can update their own sessions
CREATE POLICY "users_can_update_own_game_sessions"
ON game_sessions FOR UPDATE
USING (user_id = auth.uid());

-- GAME_SCORES: Users can select their own scores and tenant scores
CREATE POLICY "users_can_select_own_game_scores"
ON game_scores FOR SELECT
USING (
  user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- GAME_SCORES: Users can insert scores for their own sessions
CREATE POLICY "users_can_insert_game_scores"
ON game_scores FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  AND (
    tenant_id IS NULL
    OR tenant_id = ANY(get_user_tenant_ids())
  )
);

-- LEADERBOARDS: Users can select leaderboards
CREATE POLICY "users_can_select_leaderboards"
ON leaderboards FOR SELECT
USING (
  leaderboard_type = 'global'
  OR (leaderboard_type = 'tenant' AND tenant_id = ANY(get_user_tenant_ids()))
  OR (leaderboard_type = 'personal' AND user_id = auth.uid())
);

-- ACHIEVEMENTS: All authenticated users can select
CREATE POLICY "authenticated_can_select_achievements"
ON achievements FOR SELECT
USING (auth.role() = 'authenticated');

-- USER_ACHIEVEMENTS: Users can select their own
CREATE POLICY "users_can_select_own_achievements"
ON user_achievements FOR SELECT
USING (
  user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- USER_ACHIEVEMENTS: System can insert (via triggers)
CREATE POLICY "system_can_insert_user_achievements"
ON user_achievements FOR INSERT
WITH CHECK (auth.role() = 'service_role');

-- =========================================
-- 9. SEED DATA
-- =========================================

-- Insert default achievements
INSERT INTO achievements (achievement_key, name, description, condition_type, condition_value) VALUES
  ('first-game', 'First Step', 'Play your first game', 'session_count', 1),
  ('ten-games', 'Game Master', 'Play 10 games', 'session_count', 10),
  ('fifty-games', 'Dedicated', 'Play 50 games', 'session_count', 50),
  ('hundred-points', 'Century', 'Score 100+ points in one game', 'score_milestone', 100),
  ('thousand-points', 'Legend', 'Earn 1000+ total points', 'score_milestone', 1000)
ON CONFLICT (achievement_key) DO NOTHING;

-- =========================================
-- 10. COMMENTS
-- =========================================

COMMENT ON TABLE game_sessions IS 'Active and completed game play sessions';
COMMENT ON TABLE game_scores IS 'Score events during game sessions';
COMMENT ON TABLE leaderboards IS 'Aggregated leaderboard data for rankings';
COMMENT ON TABLE achievements IS 'Badge definitions for users';
COMMENT ON TABLE user_achievements IS 'User unlocked achievements';

-- =========================================
-- SUPPORT DOMAIN SCHEMA
-- Version 1.0
-- Date: 2025-11-29
-- =========================================
-- This migration adds feedback, support tickets, and bug reports for the Support Domain

-- =========================================
-- 1. ENUM TYPES
-- =========================================

CREATE TYPE ticket_status_enum AS ENUM (
  'open',
  'in_progress',
  'waiting_for_user',
  'resolved',
  'closed'
);

CREATE TYPE ticket_priority_enum AS ENUM (
  'low',
  'medium',
  'high',
  'urgent'
);

CREATE TYPE feedback_type_enum AS ENUM (
  'bug',
  'feature_request',
  'improvement',
  'other'
);

-- =========================================
-- 2. FEEDBACK TABLE
-- =========================================

CREATE TABLE feedback (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  feedback_key        text UNIQUE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  game_id             uuid REFERENCES games (id) ON DELETE SET NULL,
  type                feedback_type_enum NOT NULL DEFAULT 'other',
  title               text NOT NULL,
  description         text,
  rating              integer CHECK (rating >= 1 AND rating <= 5),
  is_anonymous        boolean NOT NULL DEFAULT false,
  status              text NOT NULL DEFAULT 'received',
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX feedback_feedback_key_idx ON feedback (feedback_key);
CREATE INDEX feedback_user_idx ON feedback (user_id);
CREATE INDEX feedback_tenant_idx ON feedback (tenant_id);
CREATE INDEX feedback_game_idx ON feedback (game_id);
CREATE INDEX feedback_type_idx ON feedback (type);
CREATE INDEX feedback_status_idx ON feedback (status);
CREATE INDEX feedback_created_at_idx ON feedback (created_at DESC);

-- =========================================
-- 3. SUPPORT TICKETS TABLE
-- =========================================

CREATE TABLE support_tickets (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_key          text UNIQUE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  assigned_to_user_id uuid REFERENCES users (id) ON DELETE SET NULL,
  title               text NOT NULL,
  description         text,
  category            text,
  status              ticket_status_enum NOT NULL DEFAULT 'open',
  priority            ticket_priority_enum NOT NULL DEFAULT 'medium',
  resolved_at         timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX support_tickets_ticket_key_idx ON support_tickets (ticket_key);
CREATE INDEX support_tickets_user_idx ON support_tickets (user_id);
CREATE INDEX support_tickets_tenant_idx ON support_tickets (tenant_id);
CREATE INDEX support_tickets_assigned_to_idx ON support_tickets (assigned_to_user_id);
CREATE INDEX support_tickets_status_idx ON support_tickets (status);
CREATE INDEX support_tickets_priority_idx ON support_tickets (priority);
CREATE INDEX support_tickets_created_at_idx ON support_tickets (created_at DESC);

-- =========================================
-- 4. TICKET MESSAGES/COMMENTS TABLE
-- =========================================

CREATE TABLE ticket_messages (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  message_key         text UNIQUE,
  ticket_id           uuid NOT NULL REFERENCES support_tickets (id) ON DELETE CASCADE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  message             text NOT NULL,
  is_internal         boolean NOT NULL DEFAULT false,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX ticket_messages_message_key_idx ON ticket_messages (message_key);
CREATE INDEX ticket_messages_ticket_idx ON ticket_messages (ticket_id);
CREATE INDEX ticket_messages_user_idx ON ticket_messages (user_id);
CREATE INDEX ticket_messages_created_at_idx ON ticket_messages (created_at);

-- =========================================
-- 5. SUPPORT STATS/REPORTS TABLE
-- =========================================

CREATE TABLE support_reports (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  report_key          text UNIQUE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  total_tickets       integer NOT NULL DEFAULT 0,
  open_tickets        integer NOT NULL DEFAULT 0,
  avg_resolution_time integer,
  satisfaction_score  numeric(3,2),
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX support_reports_report_key_idx ON support_reports (report_key);
CREATE INDEX support_reports_tenant_idx ON support_reports (tenant_id);
CREATE INDEX support_reports_created_at_idx ON support_reports (created_at DESC);

-- =========================================
-- 6. BUG REPORTS TABLE
-- =========================================

CREATE TABLE bug_reports (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  bug_report_key      text UNIQUE,
  user_id             uuid NOT NULL REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  game_id             uuid REFERENCES games (id) ON DELETE SET NULL,
  title               text NOT NULL,
  description         text NOT NULL,
  error_message       text,
  steps_to_reproduce  text,
  browser_info        text,
  status              text NOT NULL DEFAULT 'new',
  is_resolved         boolean NOT NULL DEFAULT false,
  resolved_at         timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now(),
  updated_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX bug_reports_bug_report_key_idx ON bug_reports (bug_report_key);
CREATE INDEX bug_reports_user_idx ON bug_reports (user_id);
CREATE INDEX bug_reports_tenant_idx ON bug_reports (tenant_id);
CREATE INDEX bug_reports_game_idx ON bug_reports (game_id);
CREATE INDEX bug_reports_status_idx ON bug_reports (status);
CREATE INDEX bug_reports_is_resolved_idx ON bug_reports (is_resolved);
CREATE INDEX bug_reports_created_at_idx ON bug_reports (created_at DESC);

-- =========================================
-- 7. ENABLE ROW LEVEL SECURITY
-- =========================================

ALTER TABLE feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE support_tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE ticket_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE support_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE bug_reports ENABLE ROW LEVEL SECURITY;

-- =========================================
-- 8. RLS POLICIES
-- =========================================

-- FEEDBACK: Users can select their own feedback and tenant staff can see tenant feedback
CREATE POLICY "users_can_select_own_feedback"
ON feedback FOR SELECT
USING (
  user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- FEEDBACK: Users can insert their own feedback
CREATE POLICY "users_can_insert_feedback"
ON feedback FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  AND (
    tenant_id IS NULL
    OR tenant_id = ANY(get_user_tenant_ids())
  )
);

-- FEEDBACK: Users can update their own feedback
CREATE POLICY "users_can_update_own_feedback"
ON feedback FOR UPDATE
USING (user_id = auth.uid());

-- SUPPORT_TICKETS: Users can select their own tickets and admins can see all
CREATE POLICY "users_can_select_own_tickets"
ON support_tickets FOR SELECT
USING (
  user_id = auth.uid()
  OR assigned_to_user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- SUPPORT_TICKETS: Users can insert their own tickets
CREATE POLICY "users_can_insert_tickets"
ON support_tickets FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  AND (
    tenant_id IS NULL
    OR tenant_id = ANY(get_user_tenant_ids())
  )
);

-- SUPPORT_TICKETS: Admins can update tickets for their tenant
CREATE POLICY "admins_can_update_tickets"
ON support_tickets FOR UPDATE
USING (
  tenant_id = ANY(get_user_tenant_ids())
  AND (has_tenant_role(tenant_id, 'admin') OR has_tenant_role(tenant_id, 'owner'))
);

-- TICKET_MESSAGES: Users can select messages on their tickets
CREATE POLICY "users_can_select_ticket_messages"
ON ticket_messages FOR SELECT
USING (
  ticket_id IN (
    SELECT id FROM support_tickets
    WHERE user_id = auth.uid()
       OR assigned_to_user_id = auth.uid()
       OR tenant_id = ANY(get_user_tenant_ids())
  )
);

-- TICKET_MESSAGES: Users can insert messages on their tickets
CREATE POLICY "users_can_insert_ticket_messages"
ON ticket_messages FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  AND ticket_id IN (
    SELECT id FROM support_tickets
    WHERE user_id = auth.uid()
       OR assigned_to_user_id = auth.uid()
  )
);

-- SUPPORT_REPORTS: Tenant members can select their tenant reports
CREATE POLICY "tenant_members_can_select_reports"
ON support_reports FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- BUG_REPORTS: Users can select their own bug reports
CREATE POLICY "users_can_select_own_bug_reports"
ON bug_reports FOR SELECT
USING (
  user_id = auth.uid()
  OR tenant_id = ANY(get_user_tenant_ids())
);

-- BUG_REPORTS: Users can insert their own bug reports
CREATE POLICY "users_can_insert_bug_reports"
ON bug_reports FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  AND (
    tenant_id IS NULL
    OR tenant_id = ANY(get_user_tenant_ids())
  )
);

-- =========================================
-- 9. COMMENTS
-- =========================================

COMMENT ON TABLE feedback IS 'User feedback, feature requests, and bug reports';
COMMENT ON TABLE support_tickets IS 'Support tickets and help requests';
COMMENT ON TABLE ticket_messages IS 'Conversation messages on support tickets';
COMMENT ON TABLE support_reports IS 'Support team performance metrics and statistics';
COMMENT ON TABLE bug_reports IS 'Detailed bug reports with reproduction steps';

-- =========================================
-- ANALYTICS DOMAIN SCHEMA
-- Version 1.0
-- Date: 2025-11-29
-- =========================================
-- This migration adds analytics and tracking for user engagement, feature usage, and performance

-- =========================================
-- 1. PAGE VIEWS & SESSION TRACKING
-- =========================================

CREATE TABLE page_views (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  page_view_key       text UNIQUE,
  user_id             uuid REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  page_path           text NOT NULL,
  page_title          text,
  referrer            text,
  duration_seconds    integer,
  device_type         text,
  browser_name        text,
  browser_version     text,
  os_name             text,
  os_version          text,
  ip_address          text,
  country_code        text,
  region              text,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX page_views_page_view_key_idx ON page_views (page_view_key);
CREATE INDEX page_views_user_idx ON page_views (user_id);
CREATE INDEX page_views_tenant_idx ON page_views (tenant_id);
CREATE INDEX page_views_page_path_idx ON page_views (page_path);
CREATE INDEX page_views_created_at_idx ON page_views (created_at DESC);

-- =========================================
-- 2. SESSION ANALYTICS
-- =========================================

CREATE TABLE session_analytics (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  session_key         text UNIQUE,
  user_id             uuid REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  game_id             uuid REFERENCES games (id) ON DELETE SET NULL,
  session_duration    integer NOT NULL,
  pages_visited       integer NOT NULL DEFAULT 0,
  actions_count       integer NOT NULL DEFAULT 0,
  score               integer,
  completed           boolean NOT NULL DEFAULT false,
  exit_page           text,
  device_type         text,
  referrer            text,
  entry_point         text,
  created_at          timestamptz NOT NULL DEFAULT now(),
  ended_at            timestamptz
);

CREATE INDEX session_analytics_session_key_idx ON session_analytics (session_key);
CREATE INDEX session_analytics_user_idx ON session_analytics (user_id);
CREATE INDEX session_analytics_tenant_idx ON session_analytics (tenant_id);
CREATE INDEX session_analytics_game_idx ON session_analytics (game_id);
CREATE INDEX session_analytics_completed_idx ON session_analytics (completed);
CREATE INDEX session_analytics_created_at_idx ON session_analytics (created_at DESC);

-- =========================================
-- 3. FEATURE USAGE TRACKING
-- =========================================

CREATE TABLE feature_usage (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  feature_key         text UNIQUE,
  user_id             uuid REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  feature_name        text NOT NULL,
  category            text,
  action_type         text NOT NULL,
  metadata            jsonb,
  duration_ms         integer,
  success             boolean DEFAULT true,
  error_message       text,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX feature_usage_feature_key_idx ON feature_usage (feature_key);
CREATE INDEX feature_usage_user_idx ON feature_usage (user_id);
CREATE INDEX feature_usage_tenant_idx ON feature_usage (tenant_id);
CREATE INDEX feature_usage_feature_name_idx ON feature_usage (feature_name);
CREATE INDEX feature_usage_action_type_idx ON feature_usage (action_type);
CREATE INDEX feature_usage_success_idx ON feature_usage (success);
CREATE INDEX feature_usage_created_at_idx ON feature_usage (created_at DESC);

-- =========================================
-- 4. TIME SERIES ANALYTICS (AGGREGATED)
-- =========================================

CREATE TABLE analytics_timeseries (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  timeseries_key      text UNIQUE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  metric_type         text NOT NULL,
  metric_name         text NOT NULL,
  value               numeric NOT NULL,
  count               integer NOT NULL DEFAULT 1,
  breakdown_by        text,
  breakdown_value     text,
  time_bucket         timestamptz NOT NULL,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX analytics_timeseries_timeseries_key_idx ON analytics_timeseries (timeseries_key);
CREATE INDEX analytics_timeseries_tenant_idx ON analytics_timeseries (tenant_id);
CREATE INDEX analytics_timeseries_metric_idx ON analytics_timeseries (metric_type, metric_name);
CREATE INDEX analytics_timeseries_time_bucket_idx ON analytics_timeseries (time_bucket DESC);

-- =========================================
-- 5. FUNNEL ANALYTICS
-- =========================================

CREATE TABLE funnel_analytics (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  funnel_key          text UNIQUE,
  user_id             uuid REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  funnel_name         text NOT NULL,
  step_1              boolean NOT NULL DEFAULT false,
  step_2              boolean NOT NULL DEFAULT false,
  step_3              boolean NOT NULL DEFAULT false,
  step_4              boolean NOT NULL DEFAULT false,
  step_5              boolean NOT NULL DEFAULT false,
  completed           boolean NOT NULL DEFAULT false,
  abandoned_at_step   integer,
  duration_seconds    integer,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX funnel_analytics_funnel_key_idx ON funnel_analytics (funnel_key);
CREATE INDEX funnel_analytics_user_idx ON funnel_analytics (user_id);
CREATE INDEX funnel_analytics_tenant_idx ON funnel_analytics (tenant_id);
CREATE INDEX funnel_analytics_funnel_name_idx ON funnel_analytics (funnel_name);
CREATE INDEX funnel_analytics_completed_idx ON funnel_analytics (completed);
CREATE INDEX funnel_analytics_created_at_idx ON funnel_analytics (created_at DESC);

-- =========================================
-- 6. ERROR TRACKING
-- =========================================

CREATE TABLE error_tracking (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  error_key           text UNIQUE,
  user_id             uuid REFERENCES users (id) ON DELETE CASCADE,
  tenant_id           uuid REFERENCES tenants (id) ON DELETE CASCADE,
  error_type          text NOT NULL,
  error_message       text,
  stack_trace         text,
  page_path           text,
  severity            text DEFAULT 'warning',
  resolved             boolean NOT NULL DEFAULT false,
  occurrence_count    integer NOT NULL DEFAULT 1,
  last_occurred_at    timestamptz,
  created_at          timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX error_tracking_error_key_idx ON error_tracking (error_key);
CREATE INDEX error_tracking_user_idx ON error_tracking (user_id);
CREATE INDEX error_tracking_tenant_idx ON error_tracking (tenant_id);
CREATE INDEX error_tracking_error_type_idx ON error_tracking (error_type);
CREATE INDEX error_tracking_resolved_idx ON error_tracking (resolved);
CREATE INDEX error_tracking_created_at_idx ON error_tracking (created_at DESC);

-- =========================================
-- 7. ENABLE ROW LEVEL SECURITY
-- =========================================

ALTER TABLE page_views ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE feature_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE analytics_timeseries ENABLE ROW LEVEL SECURITY;
ALTER TABLE funnel_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE error_tracking ENABLE ROW LEVEL SECURITY;

-- =========================================
-- 8. RLS POLICIES
-- =========================================

-- PAGE_VIEWS: Users can insert their own page views
CREATE POLICY "users_can_insert_page_views"
ON page_views FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  OR user_id IS NULL
);

-- PAGE_VIEWS: Admins can select all page views
CREATE POLICY "admins_can_select_page_views"
ON page_views FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- SESSION_ANALYTICS: Users can insert their own sessions
CREATE POLICY "users_can_insert_sessions"
ON session_analytics FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  OR user_id IS NULL
);

-- SESSION_ANALYTICS: Admins can select sessions
CREATE POLICY "admins_can_select_sessions"
ON session_analytics FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- FEATURE_USAGE: Users can insert their own feature usage
CREATE POLICY "users_can_insert_feature_usage"
ON feature_usage FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  OR user_id IS NULL
);

-- FEATURE_USAGE: Admins can select feature usage
CREATE POLICY "admins_can_select_feature_usage"
ON feature_usage FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- ANALYTICS_TIMESERIES: Admins can select time series
CREATE POLICY "admins_can_select_timeseries"
ON analytics_timeseries FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- ANALYTICS_TIMESERIES: System can insert time series
CREATE POLICY "system_can_insert_timeseries"
ON analytics_timeseries FOR INSERT
WITH CHECK (true);

-- FUNNEL_ANALYTICS: Users can insert their own funnels
CREATE POLICY "users_can_insert_funnels"
ON funnel_analytics FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  OR user_id IS NULL
);

-- FUNNEL_ANALYTICS: Admins can select funnels
CREATE POLICY "admins_can_select_funnels"
ON funnel_analytics FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- ERROR_TRACKING: Users can insert errors
CREATE POLICY "users_can_insert_errors"
ON error_tracking FOR INSERT
WITH CHECK (
  user_id = auth.uid()
  OR user_id IS NULL
);

-- ERROR_TRACKING: Admins can select errors
CREATE POLICY "admins_can_select_errors"
ON error_tracking FOR SELECT
USING (
  tenant_id = ANY(get_user_tenant_ids())
);

-- =========================================
-- 9. COMMENTS
-- =========================================

COMMENT ON TABLE page_views IS 'Tracks individual page views with device and geo info';
COMMENT ON TABLE session_analytics IS 'Session-level analytics with duration, completion, score';
COMMENT ON TABLE feature_usage IS 'Tracks feature adoption, action types, and performance';
COMMENT ON TABLE analytics_timeseries IS 'Aggregated time-series metrics for dashboard display';
COMMENT ON TABLE funnel_analytics IS 'Funnel conversion tracking with step-by-step progression';
COMMENT ON TABLE error_tracking IS 'Error logging and tracking with aggregation';

-- Billing Domain Schema
-- Subscriptions, billing history, invoices, and payment management

-- Billing Plans Table
CREATE TABLE public.billing_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  slug VARCHAR(50) NOT NULL UNIQUE,
  description TEXT,
  price_monthly DECIMAL(10, 2) NOT NULL,
  price_yearly DECIMAL(10, 2),
  features JSONB NOT NULL DEFAULT '{}',
  user_limit INTEGER,
  api_limit_daily INTEGER,
  storage_gb INTEGER,
  support_level VARCHAR(50),
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Subscriptions Table
CREATE TABLE public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  billing_plan_id UUID NOT NULL REFERENCES public.billing_plans(id),
  status VARCHAR(50) NOT NULL DEFAULT 'active', -- active, trialing, past_due, canceled, paused
  stripe_subscription_id VARCHAR(255),
  stripe_customer_id VARCHAR(255),
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  canceled_at TIMESTAMP,
  ended_at TIMESTAMP,
  billing_cycle VARCHAR(20) NOT NULL DEFAULT 'monthly', -- monthly, yearly
  auto_renew BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  UNIQUE(tenant_id, stripe_subscription_id)
);

-- Billing History Table
CREATE TABLE public.billing_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  subscription_id UUID REFERENCES public.subscriptions(id) ON DELETE SET NULL,
  event_type VARCHAR(100) NOT NULL, -- subscription_created, upgraded, downgraded, renewed, canceled
  from_plan_id UUID REFERENCES public.billing_plans(id),
  to_plan_id UUID REFERENCES public.billing_plans(id),
  amount_charged DECIMAL(10, 2),
  amount_credited DECIMAL(10, 2),
  notes TEXT,
  created_at TIMESTAMP DEFAULT now()
);

-- Invoices Table
CREATE TABLE public.invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  subscription_id UUID REFERENCES public.subscriptions(id) ON DELETE SET NULL,
  stripe_invoice_id VARCHAR(255) UNIQUE,
  invoice_number VARCHAR(50) NOT NULL UNIQUE,
  amount_subtotal DECIMAL(10, 2) NOT NULL,
  amount_tax DECIMAL(10, 2) DEFAULT 0,
  amount_total DECIMAL(10, 2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  status VARCHAR(50) NOT NULL DEFAULT 'draft', -- draft, open, paid, void, uncollectible
  paid_at TIMESTAMP,
  due_date TIMESTAMP,
  pdf_url VARCHAR(512),
  notes TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Payment Methods Table
CREATE TABLE public.payment_methods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  stripe_payment_method_id VARCHAR(255) UNIQUE,
  type VARCHAR(50) NOT NULL, -- card, bank_account
  card_brand VARCHAR(50),
  card_last_four VARCHAR(4),
  card_exp_month INTEGER,
  card_exp_year INTEGER,
  is_default BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Trial Usage Tracking
CREATE TABLE public.trial_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  trial_start_date TIMESTAMP NOT NULL,
  trial_end_date TIMESTAMP NOT NULL,
  users_created INTEGER DEFAULT 0,
  games_created INTEGER DEFAULT 0,
  api_calls_made INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  UNIQUE(tenant_id)
);

-- Create Indexes for Performance
CREATE INDEX idx_subscriptions_tenant_id ON public.subscriptions(tenant_id);
CREATE INDEX idx_subscriptions_status ON public.subscriptions(status);
CREATE INDEX idx_subscriptions_billing_plan_id ON public.subscriptions(billing_plan_id);
CREATE INDEX idx_billing_history_tenant_id ON public.billing_history(tenant_id);
CREATE INDEX idx_billing_history_created_at ON public.billing_history(created_at);
CREATE INDEX idx_invoices_tenant_id ON public.invoices(tenant_id);
CREATE INDEX idx_invoices_status ON public.invoices(status);
CREATE INDEX idx_invoices_created_at ON public.invoices(created_at);
CREATE INDEX idx_payment_methods_tenant_id ON public.payment_methods(tenant_id);
CREATE INDEX idx_trial_usage_tenant_id ON public.trial_usage(tenant_id);

-- Enable RLS
ALTER TABLE public.billing_plans DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.billing_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trial_usage ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Subscriptions
CREATE POLICY "Users can view their tenant subscriptions"
  ON public.subscriptions FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Admins can update subscriptions"
  ON public.subscriptions FOR UPDATE
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin')
    )
  );

CREATE POLICY "Service can insert subscriptions"
  ON public.subscriptions FOR INSERT
  WITH CHECK (true);

-- RLS Policies for Billing History
CREATE POLICY "Users can view their billing history"
  ON public.billing_history FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Service can insert billing history"
  ON public.billing_history FOR INSERT
  WITH CHECK (true);

-- RLS Policies for Invoices
CREATE POLICY "Users can view their invoices"
  ON public.invoices FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Admins can update invoices"
  ON public.invoices FOR UPDATE
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin')
    )
  );

CREATE POLICY "Service can insert invoices"
  ON public.invoices FOR INSERT
  WITH CHECK (true);

-- RLS Policies for Payment Methods
CREATE POLICY "Users can view their payment methods"
  ON public.payment_methods FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their payment methods"
  ON public.payment_methods FOR UPDATE
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin')
    )
  );

CREATE POLICY "Users can add payment methods"
  ON public.payment_methods FOR INSERT
  WITH CHECK (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

-- RLS Policies for Trial Usage
CREATE POLICY "Users can view their trial usage"
  ON public.trial_usage FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Service can manage trial usage"
  ON public.trial_usage FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Service can update trial usage"
  ON public.trial_usage FOR UPDATE
  USING (true);

-- Seed Billing Plans
-- Inserts default billing plans for the platform

INSERT INTO public.billing_plans (
  name,
  slug,
  description,
  price_monthly,
  price_yearly,
  features,
  user_limit,
  api_limit_daily,
  storage_gb,
  support_level,
  is_active
) VALUES
(
  'Free',
  'free',
  'Perfect for getting started',
  0,
  0,
  jsonb_build_object(
    'games', 3,
    'max_players', 10,
    'analytics', false,
    'api_access', false,
    'custom_branding', false
  ),
  5,
  1000,
  5,
  'community',
  true
),
(
  'Starter',
  'starter',
  'Great for small teams',
  29,
  290,
  jsonb_build_object(
    'games', 25,
    'max_players', 100,
    'analytics', true,
    'api_access', true,
    'custom_branding', false
  ),
  25,
  10000,
  50,
  'email',
  true
),
(
  'Pro',
  'pro',
  'For growing organizations',
  99,
  990,
  jsonb_build_object(
    'games', 100,
    'max_players', 1000,
    'analytics', true,
    'api_access', true,
    'custom_branding', true,
    'advanced_analytics', true,
    'webhook_support', true
  ),
  100,
  50000,
  500,
  'priority',
  true
),
(
  'Enterprise',
  'enterprise',
  'For large-scale deployments',
  499,
  4990,
  jsonb_build_object(
    'games', 'unlimited',
    'max_players', 'unlimited',
    'analytics', true,
    'api_access', true,
    'custom_branding', true,
    'advanced_analytics', true,
    'webhook_support', true,
    'sso', true,
    'dedicated_support', true,
    'custom_integration', true
  ),
  NULL,
  NULL,
  NULL,
  'dedicated',
  true
) ON CONFLICT (slug) DO NOTHING;

-- Notifications Domain Schema
-- User alerts, system notifications, and notification preferences

-- Notifications Table
CREATE TABLE public.notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  type VARCHAR(50) NOT NULL DEFAULT 'info', -- info, success, warning, error, achievement, system
  category VARCHAR(50), -- billing, gameplay, support, achievement, system
  related_entity_id UUID,
  related_entity_type VARCHAR(50), -- game, subscription, achievement, ticket
  action_url VARCHAR(512),
  action_label VARCHAR(100),
  is_read BOOLEAN DEFAULT false,
  read_at TIMESTAMP,
  expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  CONSTRAINT notification_belongs_to_user_or_tenant CHECK (
    (user_id IS NOT NULL AND tenant_id IS NOT NULL) OR
    (user_id IS NULL AND tenant_id IS NOT NULL)
  )
);

-- Notification Preferences Table
CREATE TABLE public.notification_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  tenant_id UUID REFERENCES public.tenants(id) ON DELETE CASCADE,
  email_enabled BOOLEAN DEFAULT true,
  push_enabled BOOLEAN DEFAULT true,
  sms_enabled BOOLEAN DEFAULT false,
  in_app_enabled BOOLEAN DEFAULT true,
  
  -- Category preferences
  billing_notifications BOOLEAN DEFAULT true,
  gameplay_notifications BOOLEAN DEFAULT true,
  achievement_notifications BOOLEAN DEFAULT true,
  support_notifications BOOLEAN DEFAULT true,
  system_notifications BOOLEAN DEFAULT true,
  
  -- Frequency preferences
  digest_frequency VARCHAR(50) DEFAULT 'realtime', -- realtime, daily, weekly, never
  quiet_hours_start TIME,
  quiet_hours_end TIME,
  quiet_hours_enabled BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  UNIQUE(user_id, tenant_id)
);

-- Notification Log Table (for analytics)
CREATE TABLE public.notification_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  notification_id UUID REFERENCES public.notifications(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  delivery_method VARCHAR(50), -- email, push, sms, in_app
  status VARCHAR(50) DEFAULT 'pending', -- pending, sent, failed, bounced
  sent_at TIMESTAMP,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT now()
);

-- Create Indexes for Performance
CREATE INDEX idx_notifications_tenant_id ON public.notifications(tenant_id);
CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX idx_notifications_is_read ON public.notifications(is_read);
CREATE INDEX idx_notifications_created_at ON public.notifications(created_at);
CREATE INDEX idx_notifications_expires_at ON public.notifications(expires_at);
CREATE INDEX idx_notifications_type ON public.notifications(type);
CREATE INDEX idx_notification_preferences_user_id ON public.notification_preferences(user_id);
CREATE INDEX idx_notification_preferences_tenant_id ON public.notification_preferences(tenant_id);
CREATE INDEX idx_notification_log_notification_id ON public.notification_log(notification_id);
CREATE INDEX idx_notification_log_user_id ON public.notification_log(user_id);
CREATE INDEX idx_notification_log_status ON public.notification_log(status);

-- Enable RLS
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_log ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Notifications
CREATE POLICY "Users can view their own notifications"
  ON public.notifications FOR SELECT
  USING (
    user_id = auth.uid() OR
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Service can insert notifications"
  ON public.notifications FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Users can update their own notifications"
  ON public.notifications FOR UPDATE
  USING (user_id = auth.uid());

CREATE POLICY "Users can delete their own notifications"
  ON public.notifications FOR DELETE
  USING (user_id = auth.uid());

-- RLS Policies for Notification Preferences
CREATE POLICY "Users can view their own preferences"
  ON public.notification_preferences FOR SELECT
  USING (user_id = auth.uid());

CREATE POLICY "Users can create their own preferences"
  ON public.notification_preferences FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own preferences"
  ON public.notification_preferences FOR UPDATE
  USING (user_id = auth.uid());

-- RLS Policies for Notification Log
CREATE POLICY "Service can insert notification logs"
  ON public.notification_log FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Admins can view notification logs"
  ON public.notification_log FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin')
    )
  );

-- Social Domain Schema
-- Friends, friend requests, and social leaderboards

-- Friends Table
CREATE TABLE public.friends (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id_1 UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  user_id_2 UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  tenant_id_1 UUID REFERENCES public.tenants(id) ON DELETE CASCADE,
  tenant_id_2 UUID REFERENCES public.tenants(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT now(),
  CONSTRAINT different_users CHECK (user_id_1 < user_id_2),
  CONSTRAINT users_not_same CHECK (user_id_1 != user_id_2),
  UNIQUE(user_id_1, user_id_2)
);

-- Friend Requests Table
CREATE TABLE public.friend_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  requester_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  recipient_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  status VARCHAR(50) NOT NULL DEFAULT 'pending', -- pending, accepted, rejected, blocked
  created_at TIMESTAMP DEFAULT now(),
  responded_at TIMESTAMP,
  CONSTRAINT different_users CHECK (requester_id != recipient_id),
  UNIQUE(requester_id, recipient_id)
);

-- Social Leaderboards Table
CREATE TABLE public.social_leaderboards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  game_id UUID NOT NULL REFERENCES public.games(id) ON DELETE CASCADE,
  score INTEGER NOT NULL DEFAULT 0,
  rank INTEGER,
  total_plays INTEGER DEFAULT 0,
  best_score INTEGER,
  avg_score DECIMAL(10, 2),
  achievements_unlocked INTEGER DEFAULT 0,
  last_played_at TIMESTAMP,
  updated_at TIMESTAMP DEFAULT now(),
  UNIQUE(tenant_id, user_id, game_id)
);

-- Session Multiplayer Table (for tracking multiplayer sessions)
CREATE TABLE public.multiplayer_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id UUID NOT NULL REFERENCES public.games(id) ON DELETE CASCADE,
  created_by_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  max_players INTEGER NOT NULL DEFAULT 2,
  current_players INTEGER DEFAULT 1,
  status VARCHAR(50) DEFAULT 'waiting', -- waiting, in_progress, completed, canceled
  started_at TIMESTAMP,
  ended_at TIMESTAMP,
  winner_user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Multiplayer Session Participants
CREATE TABLE public.multiplayer_participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES public.multiplayer_sessions(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  score INTEGER,
  placement INTEGER,
  joined_at TIMESTAMP DEFAULT now(),
  UNIQUE(session_id, user_id)
);

-- Create Indexes for Performance
CREATE INDEX idx_friends_user_id_1 ON public.friends(user_id_1);
CREATE INDEX idx_friends_user_id_2 ON public.friends(user_id_2);
CREATE INDEX idx_friend_requests_requester ON public.friend_requests(requester_id);
CREATE INDEX idx_friend_requests_recipient ON public.friend_requests(recipient_id);
CREATE INDEX idx_friend_requests_status ON public.friend_requests(status);
CREATE INDEX idx_social_leaderboards_tenant_id ON public.social_leaderboards(tenant_id);
CREATE INDEX idx_social_leaderboards_game_id ON public.social_leaderboards(game_id);
CREATE INDEX idx_social_leaderboards_user_id ON public.social_leaderboards(user_id);
CREATE INDEX idx_social_leaderboards_score ON public.social_leaderboards(score DESC);
CREATE INDEX idx_multiplayer_sessions_game_id ON public.multiplayer_sessions(game_id);
CREATE INDEX idx_multiplayer_sessions_created_by ON public.multiplayer_sessions(created_by_user_id);
CREATE INDEX idx_multiplayer_sessions_status ON public.multiplayer_sessions(status);
CREATE INDEX idx_multiplayer_participants_session_id ON public.multiplayer_participants(session_id);
CREATE INDEX idx_multiplayer_participants_user_id ON public.multiplayer_participants(user_id);

-- Enable RLS
ALTER TABLE public.friends ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.friend_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.social_leaderboards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.multiplayer_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.multiplayer_participants ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Friends
CREATE POLICY "Users can view their own friendships"
  ON public.friends FOR SELECT
  USING (
    user_id_1 = auth.uid() OR
    user_id_2 = auth.uid()
  );

CREATE POLICY "Service can manage friendships"
  ON public.friends FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Users can remove friendships"
  ON public.friends FOR DELETE
  USING (
    user_id_1 = auth.uid() OR
    user_id_2 = auth.uid()
  );

-- RLS Policies for Friend Requests
CREATE POLICY "Users can view their friend requests"
  ON public.friend_requests FOR SELECT
  USING (
    requester_id = auth.uid() OR
    recipient_id = auth.uid()
  );

CREATE POLICY "Users can create friend requests"
  ON public.friend_requests FOR INSERT
  WITH CHECK (requester_id = auth.uid());

CREATE POLICY "Users can update their received requests"
  ON public.friend_requests FOR UPDATE
  USING (recipient_id = auth.uid());

-- RLS Policies for Social Leaderboards
CREATE POLICY "Users can view leaderboards for their tenant"
  ON public.social_leaderboards FOR SELECT
  USING (
    tenant_id IN (
      SELECT tenant_id FROM public.user_tenant_memberships
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Service can insert leaderboard entries"
  ON public.social_leaderboards FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Service can update leaderboard entries"
  ON public.social_leaderboards FOR UPDATE
  USING (true);

-- RLS Policies for Multiplayer Sessions
CREATE POLICY "Users can view multiplayer sessions"
  ON public.multiplayer_sessions FOR SELECT
  USING (true);

CREATE POLICY "Users can create multiplayer sessions"
  ON public.multiplayer_sessions FOR INSERT
  WITH CHECK (created_by_user_id = auth.uid());

CREATE POLICY "Users can update their own sessions"
  ON public.multiplayer_sessions FOR UPDATE
  USING (created_by_user_id = auth.uid());

-- RLS Policies for Multiplayer Participants
CREATE POLICY "Users can view session participants"
  ON public.multiplayer_participants FOR SELECT
  USING (true);

CREATE POLICY "Users can join sessions"
  ON public.multiplayer_participants FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Service can update participant data"
  ON public.multiplayer_participants FOR UPDATE
  USING (true);

-- Content & Planner Domain
-- Game scheduling, content calendar, seasonal events

-- Content Items (games, collections, featured content)
CREATE TABLE IF NOT EXISTS content_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('game', 'collection', 'event', 'challenge')),
  title TEXT NOT NULL,
  description TEXT,
  image_url TEXT,
  is_published BOOLEAN DEFAULT false,
  is_featured BOOLEAN DEFAULT false,
  featured_until TIMESTAMPTZ,
  view_count INTEGER DEFAULT 0,
  created_by_user_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB DEFAULT '{}' -- store type-specific data
);

-- Content Schedule (when content should be visible/active)
CREATE TABLE IF NOT EXISTS content_schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  content_id UUID NOT NULL REFERENCES content_items(id) ON DELETE CASCADE,
  start_date TIMESTAMPTZ NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Seasonal Events (limited-time events, themed content)
CREATE TABLE IF NOT EXISTS seasonal_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  theme TEXT, -- 'halloween', 'christmas', 'summer', etc.
  start_date TIMESTAMPTZ NOT NULL,
  end_date TIMESTAMPTZ NOT NULL,
  reward_multiplier DECIMAL(3,2) DEFAULT 1.0, -- 1.5x points during event
  featured_content_id UUID REFERENCES content_items(id) ON DELETE SET NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Content Collections (curated groups of games)
CREATE TABLE IF NOT EXISTS content_collections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL, -- 'trending', 'new', 'educational', 'popular', 'custom'
  cover_image_url TEXT,
  game_count INTEGER DEFAULT 0,
  view_count INTEGER DEFAULT 0,
  is_published BOOLEAN DEFAULT false,
  is_featured BOOLEAN DEFAULT false,
  order_index INTEGER DEFAULT 0, -- for sorting on homepage
  created_by_user_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Collection Items (games in collections)
CREATE TABLE IF NOT EXISTS collection_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  collection_id UUID NOT NULL REFERENCES content_collections(id) ON DELETE CASCADE,
  game_id UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE,
  order_index INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Content Analytics (track engagement)
CREATE TABLE IF NOT EXISTS content_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  content_id UUID NOT NULL REFERENCES content_items(id) ON DELETE CASCADE,
  view_count INTEGER DEFAULT 0,
  click_count INTEGER DEFAULT 0,
  engagement_score DECIMAL(5,2) DEFAULT 0,
  last_viewed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tenant_id, content_id)
);

-- Indexes for common queries
CREATE INDEX idx_content_items_tenant_id ON content_items(tenant_id);
CREATE INDEX idx_content_items_type ON content_items(type);
CREATE INDEX idx_content_items_is_published ON content_items(is_published);
CREATE INDEX idx_content_items_is_featured ON content_items(is_featured);
CREATE INDEX idx_content_items_created_by_user_id ON content_items(created_by_user_id);

CREATE INDEX idx_content_schedules_tenant_id ON content_schedules(tenant_id);
CREATE INDEX idx_content_schedules_content_id ON content_schedules(content_id);
CREATE INDEX idx_content_schedules_start_date ON content_schedules(start_date);
CREATE INDEX idx_content_schedules_end_date ON content_schedules(end_date);

CREATE INDEX idx_seasonal_events_tenant_id ON seasonal_events(tenant_id);
CREATE INDEX idx_seasonal_events_is_active ON seasonal_events(is_active);
CREATE INDEX idx_seasonal_events_start_date ON seasonal_events(start_date);

CREATE INDEX idx_content_collections_tenant_id ON content_collections(tenant_id);
CREATE INDEX idx_content_collections_is_published ON content_collections(is_published);
CREATE INDEX idx_content_collections_is_featured ON content_collections(is_featured);
CREATE INDEX idx_content_collections_category ON content_collections(category);

CREATE INDEX idx_collection_items_collection_id ON collection_items(collection_id);
CREATE INDEX idx_collection_items_game_id ON collection_items(game_id);

CREATE INDEX idx_content_analytics_tenant_id ON content_analytics(tenant_id);
CREATE INDEX idx_content_analytics_content_id ON content_analytics(content_id);

-- RLS Policies
ALTER TABLE content_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE content_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE seasonal_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE content_collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE collection_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE content_analytics ENABLE ROW LEVEL SECURITY;

-- Content Items: Users see published content, admins see all
CREATE POLICY "content_items_published_select" ON content_items
  FOR SELECT USING (is_published = true OR auth.uid() = created_by_user_id);

CREATE POLICY "content_items_insert" ON content_items
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_items.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

CREATE POLICY "content_items_update" ON content_items
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_items.tenant_id
        AND role IN ('admin', 'editor')
    )
  ) WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_items.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

CREATE POLICY "content_items_delete" ON content_items
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_items.tenant_id
        AND role = 'admin'
    )
  );

-- Content Schedules: Admins only
CREATE POLICY "content_schedules_select" ON content_schedules
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_schedules.tenant_id
    )
  );

CREATE POLICY "content_schedules_insert" ON content_schedules
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_schedules.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

CREATE POLICY "content_schedules_update" ON content_schedules
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_schedules.tenant_id
        AND role IN ('admin', 'editor')
    )
  ) WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_schedules.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

-- Seasonal Events: Admins only
CREATE POLICY "seasonal_events_select" ON seasonal_events
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = seasonal_events.tenant_id
    )
  );

CREATE POLICY "seasonal_events_insert" ON seasonal_events
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = seasonal_events.tenant_id
        AND role = 'admin'
    )
  );

CREATE POLICY "seasonal_events_update" ON seasonal_events
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = seasonal_events.tenant_id
        AND role = 'admin'
    )
  ) WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = seasonal_events.tenant_id
        AND role = 'admin'
    )
  );

-- Content Collections: Editors can create/manage
CREATE POLICY "content_collections_select" ON content_collections
  FOR SELECT USING (is_published = true OR created_by_user_id = auth.uid());

CREATE POLICY "content_collections_insert" ON content_collections
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_collections.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

CREATE POLICY "content_collections_update" ON content_collections
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_collections.tenant_id
        AND role IN ('admin', 'editor')
    )
  ) WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_collections.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

-- Collection Items: Inherited from collection permissions
CREATE POLICY "collection_items_select" ON collection_items
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM content_collections cc
      WHERE cc.id = collection_items.collection_id
        AND (cc.is_published = true OR cc.created_by_user_id = auth.uid())
    )
  );

CREATE POLICY "collection_items_insert" ON collection_items
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM content_collections cc
      WHERE cc.id = collection_items.collection_id
        AND EXISTS (
          SELECT 1 FROM user_tenant_memberships utm
          WHERE utm.user_id = auth.uid()
            AND utm.tenant_id = cc.tenant_id
            AND utm.role IN ('admin', 'editor')
        )
    )
  );

CREATE POLICY "collection_items_delete" ON collection_items
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM content_collections cc
      WHERE cc.id = collection_items.collection_id
        AND EXISTS (
          SELECT 1 FROM user_tenant_memberships utm
          WHERE utm.user_id = auth.uid()
            AND utm.tenant_id = cc.tenant_id
            AND utm.role IN ('admin', 'editor')
        )
    )
  );

-- Content Analytics: Admins only
CREATE POLICY "content_analytics_select" ON content_analytics
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_analytics.tenant_id
    )
  );

CREATE POLICY "content_analytics_insert" ON content_analytics
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_analytics.tenant_id
    )
  );

CREATE POLICY "content_analytics_update" ON content_analytics
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_analytics.tenant_id
    )
  ) WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = content_analytics.tenant_id
    )
  );

-- Marketplace Domain
-- In-game shop, cosmetics, power-ups, virtual currency

-- Virtual Currency (coins, gems, etc)
CREATE TABLE IF NOT EXISTS virtual_currencies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  code TEXT NOT NULL UNIQUE, -- 'coins', 'gems', 'gold'
  symbol TEXT, -- '💰', '💎'
  exchange_rate DECIMAL(10,4) DEFAULT 1.0, -- relative to base currency
  is_premium BOOLEAN DEFAULT false, -- requires real money to purchase
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- User Currency Balances
CREATE TABLE IF NOT EXISTS user_currency_balances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  currency_id UUID NOT NULL REFERENCES virtual_currencies(id) ON DELETE CASCADE,
  balance DECIMAL(20,2) DEFAULT 0,
  total_earned DECIMAL(20,2) DEFAULT 0,
  total_spent DECIMAL(20,2) DEFAULT 0,
  last_transaction_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tenant_id, user_id, currency_id)
);

-- Shop Items (cosmetics, power-ups, bundles)
CREATE TABLE IF NOT EXISTS shop_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL, -- 'cosmetic', 'powerup', 'bundle', 'season_pass'
  image_url TEXT,
  price DECIMAL(10,2) NOT NULL,
  currency_id UUID NOT NULL REFERENCES virtual_currencies(id) ON DELETE SET NULL,
  quantity_limit INTEGER, -- NULL = unlimited
  quantity_sold INTEGER DEFAULT 0,
  is_available BOOLEAN DEFAULT true,
  is_featured BOOLEAN DEFAULT false,
  sort_order INTEGER DEFAULT 0,
  created_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB DEFAULT '{}' -- store type-specific data
);

-- User Purchases
CREATE TABLE IF NOT EXISTS user_purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  shop_item_id UUID NOT NULL REFERENCES shop_items(id) ON DELETE CASCADE,
  quantity INTEGER DEFAULT 1,
  price_paid DECIMAL(10,2) NOT NULL,
  currency_id UUID NOT NULL REFERENCES virtual_currencies(id) ON DELETE SET NULL,
  is_gift BOOLEAN DEFAULT false,
  gifted_from_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Cosmetics/Inventory (owned cosmetics for players)
CREATE TABLE IF NOT EXISTS player_cosmetics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  shop_item_id UUID NOT NULL REFERENCES shop_items(id) ON DELETE CASCADE,
  is_equipped BOOLEAN DEFAULT false,
  equipped_at TIMESTAMPTZ,
  acquired_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Marketplace Analytics
CREATE TABLE IF NOT EXISTS marketplace_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  date DATE DEFAULT CURRENT_DATE,
  total_purchases INTEGER DEFAULT 0,
  total_revenue DECIMAL(15,2) DEFAULT 0,
  unique_buyers INTEGER DEFAULT 0,
  average_purchase_value DECIMAL(10,2) DEFAULT 0,
  most_popular_item_id UUID REFERENCES shop_items(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tenant_id, date)
);

-- Promo Codes / Discounts
CREATE TABLE IF NOT EXISTS promo_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  code TEXT NOT NULL,
  discount_percentage DECIMAL(5,2),
  discount_amount DECIMAL(10,2),
  max_uses INTEGER,
  times_used INTEGER DEFAULT 0,
  valid_from TIMESTAMPTZ NOT NULL,
  valid_until TIMESTAMPTZ NOT NULL,
  is_active BOOLEAN DEFAULT true,
  created_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tenant_id, code)
);

-- Indexes for common queries
CREATE INDEX idx_virtual_currencies_tenant_id ON virtual_currencies(tenant_id);
CREATE INDEX idx_virtual_currencies_code ON virtual_currencies(code);

CREATE INDEX idx_user_currency_balances_tenant_id ON user_currency_balances(tenant_id);
CREATE INDEX idx_user_currency_balances_user_id ON user_currency_balances(user_id);
CREATE INDEX idx_user_currency_balances_currency_id ON user_currency_balances(currency_id);

CREATE INDEX idx_shop_items_tenant_id ON shop_items(tenant_id);
CREATE INDEX idx_shop_items_category ON shop_items(category);
CREATE INDEX idx_shop_items_is_available ON shop_items(is_available);
CREATE INDEX idx_shop_items_is_featured ON shop_items(is_featured);

CREATE INDEX idx_user_purchases_tenant_id ON user_purchases(tenant_id);
CREATE INDEX idx_user_purchases_user_id ON user_purchases(user_id);
CREATE INDEX idx_user_purchases_shop_item_id ON user_purchases(shop_item_id);
CREATE INDEX idx_user_purchases_created_at ON user_purchases(created_at);

CREATE INDEX idx_player_cosmetics_tenant_id ON player_cosmetics(tenant_id);
CREATE INDEX idx_player_cosmetics_user_id ON player_cosmetics(user_id);
CREATE INDEX idx_player_cosmetics_is_equipped ON player_cosmetics(is_equipped);

CREATE INDEX idx_marketplace_analytics_tenant_id ON marketplace_analytics(tenant_id);
CREATE INDEX idx_marketplace_analytics_date ON marketplace_analytics(date);

CREATE INDEX idx_promo_codes_tenant_id ON promo_codes(tenant_id);
CREATE INDEX idx_promo_codes_code ON promo_codes(code);
CREATE INDEX idx_promo_codes_is_active ON promo_codes(is_active);

-- RLS Policies
ALTER TABLE virtual_currencies ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_currency_balances ENABLE ROW LEVEL SECURITY;
ALTER TABLE shop_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_purchases ENABLE ROW LEVEL SECURITY;
ALTER TABLE player_cosmetics ENABLE ROW LEVEL SECURITY;
ALTER TABLE marketplace_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE promo_codes ENABLE ROW LEVEL SECURITY;

-- Virtual Currencies: Users see all, admins manage
CREATE POLICY "virtual_currencies_select" ON virtual_currencies
  FOR SELECT USING (true);

CREATE POLICY "virtual_currencies_manage" ON virtual_currencies
  FOR INSERT, UPDATE, DELETE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = virtual_currencies.tenant_id
        AND role = 'admin'
    )
  );

-- User Currency Balances: Users see own, admins see all
CREATE POLICY "user_currency_balances_select" ON user_currency_balances
  FOR SELECT USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = user_currency_balances.tenant_id
    )
  );

CREATE POLICY "user_currency_balances_insert" ON user_currency_balances
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = user_currency_balances.tenant_id
    )
  );

CREATE POLICY "user_currency_balances_update" ON user_currency_balances
  FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Shop Items: Users see available, admins manage
CREATE POLICY "shop_items_select" ON shop_items
  FOR SELECT USING (is_available = true OR created_by_user_id = auth.uid());

CREATE POLICY "shop_items_manage" ON shop_items
  FOR INSERT, UPDATE, DELETE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = shop_items.tenant_id
        AND role IN ('admin', 'editor')
    )
  );

-- User Purchases: Users see own, admins see all
CREATE POLICY "user_purchases_select" ON user_purchases
  FOR SELECT USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = user_purchases.tenant_id
    )
  );

CREATE POLICY "user_purchases_insert" ON user_purchases
  FOR INSERT WITH CHECK (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = user_purchases.tenant_id
    )
  );

-- Player Cosmetics: Users see own, admins see all
CREATE POLICY "player_cosmetics_select" ON player_cosmetics
  FOR SELECT USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = player_cosmetics.tenant_id
    )
  );

CREATE POLICY "player_cosmetics_insert" ON player_cosmetics
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "player_cosmetics_update" ON player_cosmetics
  FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Marketplace Analytics: Admins only
CREATE POLICY "marketplace_analytics_select" ON marketplace_analytics
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = marketplace_analytics.tenant_id
    )
  );

CREATE POLICY "marketplace_analytics_insert" ON marketplace_analytics
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = marketplace_analytics.tenant_id
    )
  );

-- Promo Codes: Admins manage
CREATE POLICY "promo_codes_select" ON promo_codes
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = promo_codes.tenant_id
    )
  );

CREATE POLICY "promo_codes_manage" ON promo_codes
  FOR INSERT, UPDATE, DELETE USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
        AND tenant_id = promo_codes.tenant_id
        AND role = 'admin'
    )
  );

-- Moderation Domain Tables

-- Content Reports Table
create table public.content_reports (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  reported_by_user_id uuid not null references public.users on delete cascade,
  content_type varchar not null, -- 'game', 'comment', 'user_profile', 'chat_message'
  content_id varchar not null,
  reason varchar not null, -- 'inappropriate', 'spam', 'abuse', 'copyright', 'other'
  description text,
  status varchar not null default 'pending', -- 'pending', 'under_review', 'resolved', 'dismissed'
  priority varchar not null default 'normal', -- 'low', 'normal', 'high', 'critical'
  assigned_to_user_id uuid references public.users on delete set null,
  resolution_reason text,
  resolved_at timestamp with time zone,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- Content Filter Rules Table
create table public.content_filter_rules (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  pattern varchar not null unique,
  rule_type varchar not null, -- 'keyword', 'regex', 'pattern'
  severity varchar not null, -- 'warning', 'block', 'auto_remove'
  categories text[] not null default array[]::text[], -- 'game', 'comment', 'username', etc
  is_active boolean not null default true,
  created_by_user_id uuid not null references public.users on delete cascade,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- Moderation Actions Table
create table public.moderation_actions (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  taken_by_user_id uuid not null references public.users on delete cascade,
  action_type varchar not null, -- 'warn', 'mute', 'suspend', 'ban', 'content_removal'
  target_user_id uuid references public.users on delete cascade,
  target_content_id varchar,
  reason text not null,
  duration_minutes integer, -- null for permanent
  severity varchar not null default 'warning', -- 'warning', 'moderate', 'severe'
  is_appealable boolean not null default true,
  expires_at timestamp with time zone,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- User Restrictions Table
create table public.user_restrictions (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  user_id uuid not null references public.users on delete cascade,
  restriction_type varchar not null, -- 'chat_mute', 'game_suspend', 'account_ban', 'content_flag'
  reason text not null,
  severity varchar not null default 'warning',
  active boolean not null default true,
  active_until timestamp with time zone,
  appeal_count integer not null default 0,
  can_appeal boolean not null default true,
  created_by_user_id uuid not null references public.users on delete cascade,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unique (user_id, restriction_type)
);

-- Moderation Queue Table
create table public.moderation_queue (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  report_id uuid not null references public.content_reports on delete cascade,
  priority varchar not null default 'normal',
  assigned_to_user_id uuid references public.users on delete set null,
  status varchar not null default 'pending', -- 'pending', 'in_progress', 'completed'
  assigned_at timestamp with time zone,
  completed_at timestamp with time zone,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- Moderation Analytics Table
create table public.moderation_analytics (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  date date not null,
  total_reports integer not null default 0,
  pending_reports integer not null default 0,
  resolved_reports integer not null default 0,
  actions_taken integer not null default 0,
  users_warned integer not null default 0,
  users_suspended integer not null default 0,
  users_banned integer not null default 0,
  average_resolution_time_hours numeric,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unique (tenant_id, date)
);

-- Indexes for performance
create index idx_content_reports_tenant_id on public.content_reports(tenant_id);
create index idx_content_reports_status on public.content_reports(status);
create index idx_content_reports_priority on public.content_reports(priority);
create index idx_content_reports_reported_by on public.content_reports(reported_by_user_id);
create index idx_content_reports_assigned_to on public.content_reports(assigned_to_user_id);
create index idx_content_reports_created_at on public.content_reports(created_at);

create index idx_content_filter_rules_tenant_id on public.content_filter_rules(tenant_id);
create index idx_content_filter_rules_active on public.content_filter_rules(is_active);
create index idx_content_filter_rules_pattern on public.content_filter_rules(pattern);

create index idx_moderation_actions_tenant_id on public.moderation_actions(tenant_id);
create index idx_moderation_actions_target_user on public.moderation_actions(target_user_id);
create index idx_moderation_actions_taken_by on public.moderation_actions(taken_by_user_id);
create index idx_moderation_actions_expires_at on public.moderation_actions(expires_at);

create index idx_user_restrictions_tenant_id on public.user_restrictions(tenant_id);
create index idx_user_restrictions_user_id on public.user_restrictions(user_id);
create index idx_user_restrictions_active on public.user_restrictions(active);
create index idx_user_restrictions_expires on public.user_restrictions(active_until);

create index idx_moderation_queue_tenant_id on public.moderation_queue(tenant_id);
create index idx_moderation_queue_status on public.moderation_queue(status);
create index idx_moderation_queue_assigned_to on public.moderation_queue(assigned_to_user_id);
create index idx_moderation_queue_priority on public.moderation_queue(priority);

create index idx_moderation_analytics_tenant_id on public.moderation_analytics(tenant_id);
create index idx_moderation_analytics_date on public.moderation_analytics(date);

-- RLS Policies

-- Users can view their own reports
create policy "Users can view own reports"
  on public.content_reports for select
  using (reported_by_user_id = auth.uid());

-- Moderators can view all reports for their tenant
create policy "Moderators can view all reports"
  on public.content_reports for select
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = content_reports.tenant_id
      and role in ('admin', 'moderator')
    )
  );

-- Users can create reports
create policy "Users can create reports"
  on public.content_reports for insert
  with check (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = content_reports.tenant_id
    )
  );

-- Moderators can update reports
create policy "Moderators can update reports"
  on public.content_reports for update
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = content_reports.tenant_id
      and role in ('admin', 'moderator')
    )
  );

-- Admins only for filter rules
create policy "Admins can manage filter rules"
  on public.content_filter_rules for all
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = content_filter_rules.tenant_id
      and role = 'admin'
    )
  );

-- Moderators can manage moderation actions
create policy "Moderators can manage actions"
  on public.moderation_actions for all
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = moderation_actions.tenant_id
      and role in ('admin', 'moderator')
    )
  );

-- Users can view their own restrictions
create policy "Users can view own restrictions"
  on public.user_restrictions for select
  using (user_id = auth.uid());

-- Moderators can manage restrictions
create policy "Moderators can manage restrictions"
  on public.user_restrictions for all
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = user_restrictions.tenant_id
      and role in ('admin', 'moderator')
    )
  );

-- Moderators can view and manage queue
create policy "Moderators can manage queue"
  on public.moderation_queue for all
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = moderation_queue.tenant_id
      and role in ('admin', 'moderator')
    )
  );

-- Moderators can view analytics
create policy "Moderators can view analytics"
  on public.moderation_analytics for select
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = moderation_analytics.tenant_id
      and role in ('admin', 'moderator')
    )
  );

-- Achievements Advanced Domain Tables

-- Community Challenges Table
create table public.community_challenges (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  title varchar not null,
  description text,
  challenge_type varchar not null, -- 'score', 'participation', 'speed', 'cooperation'
  difficulty varchar not null default 'normal', -- 'easy', 'normal', 'hard', 'legendary'
  target_value integer not null,
  reward_points integer not null,
  reward_currency_amount integer,
  status varchar not null default 'active', -- 'active', 'completed', 'archived'
  starts_at timestamp with time zone not null,
  ends_at timestamp with time zone not null,
  participation_count integer not null default 0,
  completion_count integer not null default 0,
  created_by_user_id uuid not null references public.users on delete cascade,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- Challenge Participation Table
create table public.challenge_participation (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  challenge_id uuid not null references public.community_challenges on delete cascade,
  user_id uuid not null references public.users on delete cascade,
  progress_value integer not null default 0,
  completed boolean not null default false,
  completed_at timestamp with time zone,
  reward_claimed boolean not null default false,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unique (challenge_id, user_id)
);

-- Limited-Time Events Table
create table public.limited_time_events (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  title varchar not null,
  description text,
  event_type varchar not null, -- 'seasonal', 'special', 'collaboration', 'anniversary'
  theme varchar,
  reward_type varchar not null, -- 'badge', 'cosmetic', 'points', 'currency'
  reward_amount integer not null,
  starts_at timestamp with time zone not null,
  ends_at timestamp with time zone not null,
  participant_count integer not null default 0,
  completion_count integer not null default 0,
  status varchar not null default 'upcoming', -- 'upcoming', 'active', 'ended'
  created_by_user_id uuid not null references public.users on delete cascade,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- Event Rewards Table
create table public.event_rewards (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  event_id uuid not null references public.limited_time_events on delete cascade,
  user_id uuid not null references public.users on delete cascade,
  reward_id varchar not null,
  reward_name varchar not null,
  claimed boolean not null default false,
  claimed_at timestamp with time zone,
  created_at timestamp with time zone not null default now()
);

-- Seasonal Achievements Table
create table public.seasonal_achievements (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  season_name varchar not null,
  season_number integer not null,
  achievement_id uuid not null references public.achievements on delete cascade,
  rarity varchar not null default 'common', -- 'common', 'rare', 'epic', 'legendary'
  exclusive_to_season boolean not null default true,
  reward_bonus_percent integer not null default 0,
  released_at timestamp with time zone not null,
  available_until timestamp with time zone,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unique (tenant_id, season_name, achievement_id)
);

-- Achievement Leaderboard Table
create table public.achievement_leaderboards (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid not null references public.tenants on delete cascade,
  user_id uuid not null references public.users on delete cascade,
  achievement_count integer not null default 0,
  seasonal_achievement_count integer not null default 0,
  total_achievement_points integer not null default 0,
  rank integer,
  season_number integer,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  unique (tenant_id, user_id, season_number)
);

-- Indexes
create index idx_community_challenges_tenant_id on public.community_challenges(tenant_id);
create index idx_community_challenges_status on public.community_challenges(status);
create index idx_community_challenges_ends_at on public.community_challenges(ends_at);
create index idx_community_challenges_active on public.community_challenges(status) where status = 'active';

create index idx_challenge_participation_tenant_id on public.challenge_participation(tenant_id);
create index idx_challenge_participation_user_id on public.challenge_participation(user_id);
create index idx_challenge_participation_challenge_id on public.challenge_participation(challenge_id);
create index idx_challenge_participation_completed on public.challenge_participation(completed);

create index idx_limited_time_events_tenant_id on public.limited_time_events(tenant_id);
create index idx_limited_time_events_status on public.limited_time_events(status);
create index idx_limited_time_events_ends_at on public.limited_time_events(ends_at);
create index idx_limited_time_events_active on public.limited_time_events(status) where status = 'active';

create index idx_event_rewards_tenant_id on public.event_rewards(tenant_id);
create index idx_event_rewards_user_id on public.event_rewards(user_id);
create index idx_event_rewards_event_id on public.event_rewards(event_id);
create index idx_event_rewards_claimed on public.event_rewards(claimed);

create index idx_seasonal_achievements_tenant_id on public.seasonal_achievements(tenant_id);
create index idx_seasonal_achievements_season on public.seasonal_achievements(season_number);
create index idx_seasonal_achievements_achievement_id on public.seasonal_achievements(achievement_id);

create index idx_achievement_leaderboards_tenant_id on public.achievement_leaderboards(tenant_id);
create index idx_achievement_leaderboards_season on public.achievement_leaderboards(season_number);
create index idx_achievement_leaderboards_rank on public.achievement_leaderboards(rank);

-- RLS Policies
create policy "Users can view challenges"
  on public.community_challenges for select
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = community_challenges.tenant_id
    )
  );

create policy "Admins can manage challenges"
  on public.community_challenges for all
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = community_challenges.tenant_id
      and role = 'admin'
    )
  );

create policy "Users can view own participation"
  on public.challenge_participation for select
  using (user_id = auth.uid());

create policy "Users can create participation"
  on public.challenge_participation for insert
  with check (user_id = auth.uid());

create policy "Users can view events"
  on public.limited_time_events for select
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = limited_time_events.tenant_id
    )
  );

create policy "Admins can manage events"
  on public.limited_time_events for all
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = limited_time_events.tenant_id
      and role = 'admin'
    )
  );

create policy "Users can view own rewards"
  on public.event_rewards for select
  using (user_id = auth.uid());

create policy "Users can view seasonal achievements"
  on public.seasonal_achievements for select
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = seasonal_achievements.tenant_id
    )
  );

create policy "Users can view achievement leaderboards"
  on public.achievement_leaderboards for select
  using (
    exists (
      select 1 from public.user_tenant_memberships
      where user_id = auth.uid()
      and tenant_id = achievement_leaderboards.tenant_id
    )
  );

-- Personalization Domain: User preferences, recommendations, and customization
-- Tracks user preferences, content recommendations, interest profiles, and personalization settings

-- User Preferences Table
CREATE TABLE user_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Preference Settings
  language VARCHAR(10),
  theme 'light' | 'dark' | 'auto',
  notifications_enabled BOOLEAN DEFAULT true,
  email_frequency VARCHAR(20) DEFAULT 'weekly', -- daily, weekly, monthly, never
  
  -- Content Preferences
  preferred_game_categories TEXT[] DEFAULT '{}',
  difficulty_preference VARCHAR(20), -- easy, medium, hard, mixed
  content_maturity_level VARCHAR(20) DEFAULT 'teen', -- kids, teen, mature
  
  -- Privacy Settings
  profile_visibility VARCHAR(20) DEFAULT 'public', -- public, friends_only, private
  show_stats_publicly BOOLEAN DEFAULT true,
  allow_friend_requests BOOLEAN DEFAULT true,
  allow_messages BOOLEAN DEFAULT true,
  
  -- Recommendation Settings
  enable_recommendations BOOLEAN DEFAULT true,
  recommendation_frequency VARCHAR(20) DEFAULT 'weekly',
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(tenant_id, user_id),
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Saved Items Table (bookmarks, favorites)
CREATE TABLE saved_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  item_type VARCHAR(50) NOT NULL, -- game, challenge, event, achievement, content
  item_id UUID NOT NULL,
  item_title VARCHAR(255),
  item_metadata JSONB,
  
  saved_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(tenant_id, user_id, item_type, item_id),
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Personalization Events Table (clicks, views, interactions)
CREATE TABLE personalization_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  event_type VARCHAR(50) NOT NULL, -- view, click, complete, save, share
  item_type VARCHAR(50),
  item_id UUID,
  item_title VARCHAR(255),
  
  event_metadata JSONB, -- time_spent, context, etc
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Recommendation History Table
CREATE TABLE recommendation_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  recommendation_id UUID DEFAULT gen_random_uuid(),
  item_type VARCHAR(50), -- game, challenge, event, achievement
  item_id UUID,
  item_title VARCHAR(255),
  
  -- Recommendation Details
  reason VARCHAR(255), -- trending, popular, similar_to_interests, personalized_recommendation
  confidence_score FLOAT DEFAULT 0.5, -- 0.0-1.0
  rank_position INTEGER,
  
  -- Interaction
  was_clicked BOOLEAN DEFAULT false,
  was_completed BOOLEAN DEFAULT false,
  interaction_timestamp TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE,
  
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Interest Profiles Table
CREATE TABLE interest_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Interest Categories
  interest_category VARCHAR(100),
  interest_weight FLOAT DEFAULT 0.5, -- 0.0-1.0, importance
  interest_activity INTEGER DEFAULT 0, -- engagement count
  
  -- Trending & Seasonal
  is_trending BOOLEAN DEFAULT false,
  trend_score FLOAT DEFAULT 0,
  last_engagement_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(tenant_id, user_id, interest_category),
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Content Preferences Table (genre/tag preferences)
CREATE TABLE content_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Content Details
  content_category VARCHAR(100),
  preference_level VARCHAR(20) DEFAULT 'neutral', -- love, like, neutral, dislike, hate
  frequency_preference VARCHAR(20), -- frequent, occasional, rare
  
  -- Engagement
  engagement_count INTEGER DEFAULT 0,
  last_engaged_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(tenant_id, user_id, content_category),
  CONSTRAINT fk_tenant FOREIGN KEY(tenant_id) REFERENCES tenants(id),
  CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id)
);

-- Create Indexes
CREATE INDEX idx_user_preferences_tenant ON user_preferences(tenant_id);
CREATE INDEX idx_user_preferences_user ON user_preferences(user_id);
CREATE INDEX idx_saved_items_tenant ON saved_items(tenant_id);
CREATE INDEX idx_saved_items_user ON saved_items(user_id);
CREATE INDEX idx_saved_items_type ON saved_items(item_type);
CREATE INDEX idx_personalization_events_tenant ON personalization_events(tenant_id);
CREATE INDEX idx_personalization_events_user ON personalization_events(user_id);
CREATE INDEX idx_personalization_events_type ON personalization_events(event_type);
CREATE INDEX idx_recommendation_history_tenant ON recommendation_history(tenant_id);
CREATE INDEX idx_recommendation_history_user ON recommendation_history(user_id);
CREATE INDEX idx_recommendation_history_clicked ON recommendation_history(was_clicked);
CREATE INDEX idx_interest_profiles_tenant ON interest_profiles(tenant_id);
CREATE INDEX idx_interest_profiles_user ON interest_profiles(user_id);
CREATE INDEX idx_interest_profiles_category ON interest_profiles(interest_category);
CREATE INDEX idx_content_preferences_tenant ON content_preferences(tenant_id);
CREATE INDEX idx_content_preferences_user ON content_preferences(user_id);
CREATE INDEX idx_content_preferences_category ON content_preferences(content_category);

-- Enable RLS
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE saved_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE personalization_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE recommendation_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE interest_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE content_preferences ENABLE ROW LEVEL SECURITY;

-- RLS Policies: User Preferences
CREATE POLICY user_preferences_user_select ON user_preferences
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY user_preferences_user_update ON user_preferences
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY user_preferences_admin_all ON user_preferences
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
      AND tenant_id = user_preferences.tenant_id
      AND role IN ('admin', 'owner')
    )
  );

-- RLS Policies: Saved Items
CREATE POLICY saved_items_user_select ON saved_items
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY saved_items_user_crud ON saved_items
  FOR ALL USING (user_id = auth.uid());

-- RLS Policies: Personalization Events
CREATE POLICY personalization_events_user_insert ON personalization_events
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY personalization_events_user_select ON personalization_events
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY personalization_events_admin_all ON personalization_events
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
      AND tenant_id = personalization_events.tenant_id
      AND role IN ('admin', 'owner')
    )
  );

-- RLS Policies: Recommendation History
CREATE POLICY recommendation_history_user_select ON recommendation_history
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY recommendation_history_user_update ON recommendation_history
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY recommendation_history_admin_all ON recommendation_history
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
      AND tenant_id = recommendation_history.tenant_id
      AND role IN ('admin', 'owner')
    )
  );

-- RLS Policies: Interest Profiles
CREATE POLICY interest_profiles_user_select ON interest_profiles
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY interest_profiles_admin_all ON interest_profiles
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM user_tenant_memberships
      WHERE user_id = auth.uid()
      AND tenant_id = interest_profiles.tenant_id
      AND role IN ('admin', 'owner')
    )
  );

-- RLS Policies: Content Preferences
CREATE POLICY content_preferences_user_select ON content_preferences
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY content_preferences_user_crud ON content_preferences
  FOR ALL USING (user_id = auth.uid());

